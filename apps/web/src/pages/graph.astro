---
import BaseLayout from '../layouts/BaseLayout.astro';
import { getAllPatterns } from '../lib/patterns';
import type { PatternGraph, GraphEdge, GraphNode } from '../types';

const patterns = await getAllPatterns();
const nodeIds = new Set(patterns.map((pattern) => pattern.id));

const graphData: PatternGraph = {
  nodes: patterns.map((pattern) => ({
    id: pattern.id,
    title: pattern.title,
    category: pattern.category,
    status: pattern.status,
    slug: pattern.slug,
    tags: pattern.tags,
  })),
  edges: patterns.flatMap((pattern) => {
    const relatedEdges =
      pattern.related
        ?.filter((id) => nodeIds.has(id))
        .map((id) => ({ source: pattern.id, target: id, type: 'related' as const })) || [];
    const antiEdges =
      pattern.anti_patterns
        ?.filter((id) => nodeIds.has(id))
        .map((id) => ({ source: pattern.id, target: id, type: 'anti-pattern' as const })) || [];
    return [...relatedEdges, ...antiEdges];
  }),
};

// Get unique values for filters
const categories = [...new Set(graphData.nodes.map((n: GraphNode) => n.category))].sort();
const statuses = [...new Set(graphData.nodes.map((n: GraphNode) => n.status))].sort();

const positionedNodes = graphData.nodes.map((node: GraphNode, index: number) => {
  const angle = (index / Math.max(graphData.nodes.length, 1)) * 2 * Math.PI;
  const radius = 200 + (index % 3) * 50;
  const x = 400 + Math.cos(angle) * radius;
  const y = 300 + Math.sin(angle) * radius;

  return {
    ...node,
    x,
    y,
  };
});

const nodeById = new Map(positionedNodes.map((node) => [node.id, node]));

const positionedEdges = graphData.edges
  .map((edge) => {
    const source = nodeById.get(edge.source);
    const target = nodeById.get(edge.target);
    if (!source || !target) return null;
    return {
      ...edge,
      x1: source.x,
      y1: source.y,
      x2: target.x,
      y2: target.y,
    } as GraphEdge;
  })
  .filter(Boolean) as GraphEdge[];

// Helper functions for category/status colors
function getCategoryColor(category: string): string {
  const colors: Record<string, string> = {
    'Orchestration & Control': '#3b82f6',
    'Context & Memory': '#8b5cf6',
    'Feedback Loops': '#ec4899',
    'Learning & Adaptation': '#f59e0b',
    'Reliability & Eval': '#10b981',
    'Security & Safety': '#ef4444',
    'Tool Use & Environment': '#06b6d4',
    'UX & Collaboration': '#f97316',
  };
  return colors[category] || '#6b7280';
}
---

<BaseLayout title="Pattern Graph - Awesome Agentic Patterns">
  <div class="graph-page">
    <header class="graph-header">
      <h1>Pattern Graph</h1>
      <p class="graph-subtitle">Explore relationships between AI agent design patterns.</p>
    </header>

    <div class="graph-layout">
      <!-- Filters Sidebar -->
      <aside class="graph-filters">
        <div class="filter-section">
          <h3 class="filter-title">Category</h3>
          <div class="filter-options">
            {
              categories.map((category) => (
                <label class="filter-option">
                  <input type="checkbox" value={category} data-filter="category" />
                  <span>{category}</span>
                  <span class="filter-count">
                    {graphData.nodes.filter((n: GraphNode) => n.category === category).length}
                  </span>
                </label>
              ))
            }
          </div>
        </div>

        <div class="filter-section">
          <h3 class="filter-title">Status</h3>
          <div class="filter-options">
            {
              statuses.map((status) => (
                <label class="filter-option">
                  <input type="checkbox" value={status} data-filter="status" />
                  <span>{status}</span>
                  <span class="filter-count">
                    {graphData.nodes.filter((n: GraphNode) => n.status === status).length}
                  </span>
                </label>
              ))
            }
          </div>
        </div>

        <a href="/graph" class="clear-filters" id="graph-clear-filters" hidden>
          Clear All Filters
        </a>
      </aside>

      <!-- Graph Canvas -->
      <div class="graph-canvas-container">
        <div class="graph-info">
          Showing <span id="graph-count">{graphData.nodes.length}</span> of {graphData.nodes.length}
          patterns
        </div>

        <div class="graph-canvas" id="graph-canvas">
          <svg width="100%" height="600" viewBox="0 0 800 600" class="graph-svg">
            <defs>
              <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
                <feGaussianBlur stdDeviation="3" result="coloredBlur"></feGaussianBlur>
                <feMerge>
                  <feMergeNode in="coloredBlur"></feMergeNode>
                  <feMergeNode in="SourceGraphic"></feMergeNode>
                </feMerge>
              </filter>
            </defs>

            <!-- Edges -->
            {
              positionedEdges.map((edge) => (
                <line
                  x1={edge.x1}
                  y1={edge.y1}
                  x2={edge.x2}
                  y2={edge.y2}
                  stroke="var(--color-border)"
                  stroke-width="2"
                  class="graph-edge"
                  data-edge
                  data-source={edge.source}
                  data-target={edge.target}
                />
              ))
            }

            <!-- Nodes -->
            {
              positionedNodes.map((node: GraphNode & { x: number; y: number }) => {
                const categoryColor = getCategoryColor(node.category);

                return (
                  <g
                    class="graph-node"
                    data-node-id={node.id}
                    data-category={node.category}
                    data-status={node.status}
                    data-tags={(node.tags || []).join('|')}
                    data-title={node.title}
                    data-slug={node.slug}
                    style="--category-color: {categoryColor}"
                  >
                    <circle
                      cx={node.x}
                      cy={node.y}
                      r="24"
                      fill={categoryColor}
                      class="node-circle"
                      data-node-circle={node.id}
                    />
                    <text x={node.x} y={node.y + 35} text-anchor="middle" class="node-label">
                      {node.title.length > 30 ? node.title.slice(0, 30) + '...' : node.title}
                    </text>
                    <foreignObject
                      x={node.x - 100}
                      y={node.y - 100}
                      width="200"
                      height="80"
                      class="node-tooltip"
                    >
                      <div xmlns="http://www.w3.org/1999/xhtml">
                        <>
                          <strong>{node.title}</strong>
                          <br />
                        </>
                        <>
                          <span class="tooltip-category">{node.category}</span>
                          <br />
                        </>
                        <span class="tooltip-status">{node.status}</span>
                      </div>
                    </foreignObject>
                    <a href={`/graph?node=${node.id}`} class="node-link" data-node-id={node.id}>
                      <circle cx={node.x} cy={node.y} r="32" fill="transparent" />
                    </a>
                  </g>
                );
              })
            }
          </svg>
        </div>

        <!-- Detail Panel -->
        <div class="graph-detail-panel" id="graph-detail" hidden>
          <button class="detail-close" id="detail-close">×</button>

          <h2 class="detail-title" id="detail-title"></h2>

          <div class="detail-meta">
            <span class="detail-category" id="detail-category"></span>
            <span class="detail-status" id="detail-status"></span>
          </div>

          <a href="/patterns" class="detail-link" id="detail-link"> View Full Pattern → </a>
        </div>
      </div>
    </div>
  </div>
</BaseLayout>

<script>
  const params = new URLSearchParams(window.location.search);
  const selectedCategories = params.getAll('category');
  const selectedStatuses = params.getAll('status');
  const selectedTags = params.getAll('tag');
  const selectedNodeId = params.get('node');

  const clearFiltersLink = document.getElementById('graph-clear-filters');
  const countEl = document.getElementById('graph-count');
  const nodeElements = document.querySelectorAll('.graph-node');
  const edgeElements = document.querySelectorAll('[data-edge]');
  const categoryFilters = document.querySelectorAll('input[data-filter="category"]');
  const statusFilters = document.querySelectorAll('input[data-filter="status"]');

  const detailPanel = document.getElementById('graph-detail');
  const detailTitle = document.getElementById('detail-title');
  const detailCategory = document.getElementById('detail-category');
  const detailStatus = document.getElementById('detail-status');
  const detailLink = document.getElementById('detail-link');
  const detailClose = document.getElementById('detail-close');

  const applyFilters = () => {
    const visibleNodes = new Set();
    nodeElements.forEach((node) => {
      const category = node.getAttribute('data-category') || '';
      const status = node.getAttribute('data-status') || '';
      const tags = (node.getAttribute('data-tags') || '').split('|').filter(Boolean);

      let matches = true;
      if (selectedCategories.length > 0 && !selectedCategories.includes(category)) {
        matches = false;
      }
      if (selectedStatuses.length > 0 && !selectedStatuses.includes(status)) {
        matches = false;
      }
      if (selectedTags.length > 0 && !tags.some((tag) => selectedTags.includes(tag))) {
        matches = false;
      }

      node.style.display = matches ? '' : 'none';
      if (matches) {
        const nodeId = node.getAttribute('data-node-id');
        if (nodeId) visibleNodes.add(nodeId);
      }
    });

    edgeElements.forEach((edge) => {
      const source = edge.getAttribute('data-source');
      const target = edge.getAttribute('data-target');
      const show = source && target && visibleNodes.has(source) && visibleNodes.has(target);
      edge.style.display = show ? '' : 'none';
    });

    if (countEl) {
      countEl.textContent = String(visibleNodes.size);
    }

    if (clearFiltersLink) {
      clearFiltersLink.hidden =
        selectedCategories.length === 0 &&
        selectedStatuses.length === 0 &&
        selectedTags.length === 0;
    }
  };

  const updateFilterInputs = () => {
    categoryFilters.forEach((input) => {
      input.checked = selectedCategories.includes(input.value);
      input.addEventListener('change', () => {
        const params = new URLSearchParams(window.location.search);
        const values = params.getAll('category');
        if (input.checked) {
          values.push(input.value);
        } else {
          const index = values.indexOf(input.value);
          if (index !== -1) values.splice(index, 1);
        }
        params.delete('category');
        values.forEach((value) => params.append('category', value));
        window.location.search = params.toString();
      });
    });

    statusFilters.forEach((input) => {
      input.checked = selectedStatuses.includes(input.value);
      input.addEventListener('change', () => {
        const params = new URLSearchParams(window.location.search);
        const values = params.getAll('status');
        if (input.checked) {
          values.push(input.value);
        } else {
          const index = values.indexOf(input.value);
          if (index !== -1) values.splice(index, 1);
        }
        params.delete('status');
        values.forEach((value) => params.append('status', value));
        window.location.search = params.toString();
      });
    });
  };

  const updateDetailPanel = () => {
    if (!detailPanel) return;

    document.querySelectorAll('[data-node-circle]').forEach((circle) => {
      circle.removeAttribute('filter');
    });

    if (!selectedNodeId) {
      detailPanel.hidden = true;
      return;
    }

    const node = document.querySelector(`.graph-node[data-node-id="${selectedNodeId}"]`);
    if (!node) {
      detailPanel.hidden = true;
      return;
    }

    if (node.style.display === 'none') {
      detailPanel.hidden = true;
      return;
    }

    const title = node.getAttribute('data-title') || '';
    const category = node.getAttribute('data-category') || '';
    const status = node.getAttribute('data-status') || '';
    const slug = node.getAttribute('data-slug') || '';

    if (detailTitle) detailTitle.textContent = title;
    if (detailCategory) detailCategory.textContent = category;
    if (detailStatus) detailStatus.textContent = status;
    if (detailLink && slug) detailLink.setAttribute('href', `/patterns/${slug}`);

    if (detailStatus) {
      detailStatus.style.setProperty('--status-color', getStatusColor(status));
    }

    const nodeCircle = document.querySelector(`[data-node-circle="${selectedNodeId}"]`);
    if (nodeCircle) {
      nodeCircle.setAttribute('filter', 'url(#glow)');
    }

    detailPanel.hidden = false;
  };

  const getStatusColor = (status) => {
    const colors = {
      proposed: '#9ca3af',
      emerging: '#60a5fa',
      established: '#34d399',
      'validated-in-production': '#10b981',
      'best-practice': '#059669',
      'experimental-but-awesome': '#f59e0b',
      'rapidly-improving': '#8b5cf6',
    };
    return colors[status] || '#6b7280';
  };

  if (detailClose) {
    detailClose.addEventListener('click', () => {
      window.location.href = '/graph';
    });
  }

  updateFilterInputs();
  applyFilters();
  updateDetailPanel();
</script>

<style>
  .graph-page {
    max-width: 1600px;
    margin: 0 auto;
    padding: var(--spacing-xl) var(--spacing-lg);
  }

  .graph-header {
    text-align: center;
    margin-bottom: var(--spacing-2xl);
  }

  .graph-header h1 {
    font-size: 2.5rem;
    font-weight: 700;
    color: var(--color-text);
    margin-bottom: var(--spacing-md);
  }

  .graph-subtitle {
    font-size: 1.125rem;
    color: var(--color-text-muted);
  }

  .graph-layout {
    display: grid;
    grid-template-columns: 280px 1fr;
    gap: var(--spacing-xl);
  }

  .graph-filters {
    position: sticky;
    top: 100px;
    max-height: calc(100vh - 120px);
    overflow-y: auto;
    padding: var(--spacing-lg);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-lg);
    background-color: var(--color-bg);
  }

  .filter-section {
    margin-bottom: var(--spacing-lg);
  }

  .filter-section:last-child {
    margin-bottom: 0;
  }

  .filter-title {
    font-size: 0.875rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--color-text-muted);
    margin-bottom: var(--spacing-md);
  }

  .filter-options {
    display: flex;
    flex-direction: column;
    gap: var(--spacing-sm);
  }

  .filter-option {
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
    cursor: pointer;
    padding: var(--spacing-xs);
    border-radius: var(--radius-sm);
    transition: background-color 0.2s ease;
  }

  .filter-option:hover {
    background-color: var(--color-border);
  }

  .filter-option input[type='checkbox'] {
    cursor: pointer;
  }

  .filter-option span:first-of-type {
    flex: 1;
    font-size: 0.875rem;
    color: var(--color-text);
  }

  .filter-count {
    font-size: 0.75rem;
    color: var(--color-text-muted);
    background-color: var(--color-border);
    padding: 2px 6px;
    border-radius: 10px;
  }

  .clear-filters {
    display: block;
    width: 100%;
    padding: var(--spacing-sm);
    text-align: center;
    background-color: var(--color-primary);
    color: white;
    text-decoration: none;
    border-radius: var(--radius-md);
    font-size: 0.875rem;
    font-weight: 500;
  }

  .clear-filters:hover {
    background-color: var(--color-primary-dark);
  }

  .graph-canvas-container {
    position: relative;
  }

  .graph-info {
    margin-bottom: var(--spacing-md);
    padding: var(--spacing-md);
    background-color: var(--color-border);
    border-radius: var(--radius-md);
    font-size: 0.875rem;
    color: var(--color-text-muted);
    text-align: center;
  }

  .graph-canvas {
    border: 1px solid var(--color-border);
    border-radius: var(--radius-lg);
    background-color: var(--color-bg);
    overflow: hidden;
  }

  .graph-svg {
    display: block;
  }

  .graph-edge {
    opacity: 0.3;
  }

  .graph-node {
    cursor: pointer;
  }

  .node-circle {
    stroke: white;
    stroke-width: 2;
    transition: all 0.2s ease;
  }

  .graph-node:hover .node-circle {
    stroke-width: 3;
    filter: drop-shadow(0 0 8px var(--category-color));
  }

  .node-label {
    font-size: 12px;
    fill: var(--color-text);
    pointer-events: none;
  }

  .node-tooltip {
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.2s ease;
  }

  .graph-node:hover .node-tooltip {
    opacity: 1;
  }

  .node-tooltip div {
    padding: var(--spacing-sm);
    background-color: var(--color-bg);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-md);
    font-size: 0.875rem;
    color: var(--color-text);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  }

  .tooltip-category {
    display: block;
    font-size: 0.75rem;
    color: var(--color-text-muted);
    margin-top: var(--spacing-xs);
  }

  .tooltip-status {
    display: block;
    font-size: 0.75rem;
    color: var(--color-primary);
    margin-top: var(--spacing-xs);
  }

  .node-link {
    cursor: pointer;
  }

  .graph-detail-panel {
    position: absolute;
    top: 20px;
    right: 20px;
    width: 320px;
    padding: var(--spacing-lg);
    background-color: var(--color-bg);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-lg);
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.1);
    z-index: 10;
  }

  .detail-close {
    position: absolute;
    top: var(--spacing-sm);
    right: var(--spacing-sm);
    width: 32px;
    height: 32px;
    border: none;
    background: transparent;
    font-size: 1.5rem;
    color: var(--color-text-muted);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: var(--radius-sm);
    transition: all 0.2s ease;
  }

  .detail-close:hover {
    background-color: var(--color-border);
    color: var(--color-text);
  }

  .detail-title {
    font-size: 1.25rem;
    font-weight: 600;
    color: var(--color-text);
    margin-bottom: var(--spacing-md);
    padding-right: var(--spacing-lg);
  }

  .detail-meta {
    display: flex;
    flex-wrap: wrap;
    gap: var(--spacing-sm);
    margin-bottom: var(--spacing-lg);
  }

  .detail-category,
  .detail-status {
    padding: var(--spacing-xs) var(--spacing-sm);
    border-radius: var(--radius-sm);
    font-size: 0.75rem;
    font-weight: 500;
  }

  .detail-category {
    background-color: var(--color-border);
    color: var(--color-text);
  }

  .detail-status {
    background-color: var(--status-color);
    color: white;
  }

  .detail-link {
    display: inline-block;
    padding: var(--spacing-sm) var(--spacing-lg);
    background-color: var(--color-primary);
    color: white;
    text-decoration: none;
    border-radius: var(--radius-md);
    font-weight: 500;
    transition: background-color 0.2s ease;
  }

  .detail-link:hover {
    background-color: var(--color-primary-dark);
  }

  @media (max-width: 1024px) {
    .graph-layout {
      grid-template-columns: 1fr;
    }

    .graph-filters {
      position: static;
      max-height: none;
    }

    .graph-detail-panel {
      position: static;
      width: 100%;
      margin-top: var(--spacing-lg);
    }
  }

  @media (max-width: 640px) {
    .graph-page {
      padding: var(--spacing-md) var(--spacing-sm);
    }

    .graph-header h1 {
      font-size: 1.75rem;
    }

    .graph-subtitle {
      font-size: 1rem;
    }

    .graph-canvas {
      min-height: 400px;
    }

    .node-circle {
      r: 28 !important;
    }

    .node-link circle {
      r: 36 !important;
    }

    .node-label {
      font-size: 10px;
    }
  }
</style>
