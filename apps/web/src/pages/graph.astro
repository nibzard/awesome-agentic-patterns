---
import BaseLayout from '../layouts/BaseLayout.astro';
import { getAllPatterns } from '../lib/patterns';
import type { PatternGraph, GraphEdge, GraphNode } from '../types';

const patterns = await getAllPatterns();
const nodeIds = new Set(patterns.map((pattern) => pattern.id));

const graphData: PatternGraph = {
  nodes: patterns.map((pattern) => ({
    id: pattern.id,
    title: pattern.title,
    category: pattern.category,
    status: pattern.status,
    slug: pattern.slug,
    tags: pattern.tags,
    summary: pattern.summary,
    maturity: pattern.maturity,
    domains: pattern.domains,
  })),
  edges: patterns.flatMap((pattern) => {
    const relatedEdges =
      pattern.related
        ?.filter((id) => nodeIds.has(id))
        .map((id) => ({ source: pattern.id, target: id, type: 'related' as const })) || [];
    const antiEdges =
      pattern.anti_patterns
        ?.filter((id) => nodeIds.has(id))
        .map((id) => ({ source: pattern.id, target: id, type: 'anti-pattern' as const })) || [];
    return [...relatedEdges, ...antiEdges];
  }),
};

// Get unique values for filters
const categories = [...new Set(graphData.nodes.map((n: GraphNode) => n.category))].sort();
const statuses = [...new Set(graphData.nodes.map((n: GraphNode) => n.status))].sort();

const tagMap = graphData.nodes.reduce((acc: Record<string, number>, node: GraphNode) => {
  (node.tags || []).forEach((tag) => {
    acc[tag] = (acc[tag] || 0) + 1;
  });
  return acc;
}, {});

const tags = Object.entries(tagMap)
  .map(([tag, count]) => ({ tag, count }))
  .sort((a, b) => b.count - a.count)
  .slice(0, 20);

const maturityMap = graphData.nodes.reduce((acc: Record<string, number>, node: GraphNode) => {
  if (node.maturity) {
    acc[node.maturity] = (acc[node.maturity] || 0) + 1;
  }
  return acc;
}, {});

const maturities = Object.entries(maturityMap)
  .map(([maturity, count]) => ({ maturity, count }))
  .sort((a, b) => b.count - a.count);

const domainMap = graphData.nodes.reduce((acc: Record<string, number>, node: GraphNode) => {
  (node.domains || []).forEach((domain) => {
    acc[domain] = (acc[domain] || 0) + 1;
  });
  return acc;
}, {});

const domains = Object.entries(domainMap)
  .map(([domain, count]) => ({ domain, count }))
  .sort((a, b) => b.count - a.count);

const positionedNodes = graphData.nodes.map((node: GraphNode, index: number) => {
  const angle = (index / Math.max(graphData.nodes.length, 1)) * 2 * Math.PI;
  const radius = 200 + (index % 3) * 50;
  const x = 400 + Math.cos(angle) * radius;
  const y = 300 + Math.sin(angle) * radius;

  return {
    ...node,
    x,
    y,
  };
});

const nodeById = new Map(positionedNodes.map((node) => [node.id, node]));

const positionedEdges = graphData.edges
  .map((edge) => {
    const source = nodeById.get(edge.source);
    const target = nodeById.get(edge.target);
    if (!source || !target) return null;
    return {
      ...edge,
      x1: source.x,
      y1: source.y,
      x2: target.x,
      y2: target.y,
    } as GraphEdge;
  })
  .filter(Boolean) as GraphEdge[];

// Helper functions for category/status colors
function getCategoryColor(category: string): string {
  const colors: Record<string, string> = {
    'Orchestration & Control': '#3b82f6',
    'Context & Memory': '#8b5cf6',
    'Feedback Loops': '#ec4899',
    'Learning & Adaptation': '#f59e0b',
    'Reliability & Eval': '#10b981',
    'Security & Safety': '#ef4444',
    'Tool Use & Environment': '#06b6d4',
    'UX & Collaboration': '#f97316',
  };
  return colors[category] || '#6b7280';
}
---

<BaseLayout title="Pattern Graph - Awesome Agentic Patterns">
  <div class="graph-page">
    <header class="graph-header">
      <h1>Pattern Graph</h1>
      <p class="graph-subtitle">Explore relationships between AI agent design patterns.</p>
    </header>

    <div class="graph-layout">
      <!-- Filters Sidebar -->
      <aside class="graph-filters">
        <div class="filter-section">
          <h3 class="filter-title">Category</h3>
          <div class="filter-options">
            {
              categories.map((category) => (
                <label class="filter-option">
                  <input type="checkbox" value={category} data-filter="category" />
                  <span>{category}</span>
                  <span class="filter-count">
                    {graphData.nodes.filter((n: GraphNode) => n.category === category).length}
                  </span>
                </label>
              ))
            }
          </div>
        </div>

        <div class="filter-section">
          <h3 class="filter-title">Status</h3>
          <div class="filter-options">
            {
              statuses.map((status) => (
                <label class="filter-option">
                  <input type="checkbox" value={status} data-filter="status" />
                  <span>{status}</span>
                  <span class="filter-count">
                    {graphData.nodes.filter((n: GraphNode) => n.status === status).length}
                  </span>
                </label>
              ))
            }
          </div>
        </div>

        {
          maturities.length > 0 && (
            <div class="filter-section">
              <h3 class="filter-title">Maturity</h3>
              <div class="filter-options">
                {maturities.map(({ maturity, count }) => (
                  <label class="filter-option">
                    <input type="checkbox" value={maturity} data-filter="maturity" />
                    <span>{maturity}</span>
                    <span class="filter-count">{count}</span>
                  </label>
                ))}
              </div>
            </div>
          )
        }

        {
          tags.length > 0 && (
            <div class="filter-section">
              <h3 class="filter-title">Tags</h3>
              <div class="filter-options">
                {tags.map(({ tag, count }) => (
                  <label class="filter-option">
                    <input type="checkbox" value={tag} data-filter="tag" />
                    <span>{tag}</span>
                    <span class="filter-count">{count}</span>
                  </label>
                ))}
              </div>
            </div>
          )
        }

        {
          domains.length > 0 && (
            <div class="filter-section">
              <h3 class="filter-title">Domains</h3>
              <div class="filter-options">
                {domains.map(({ domain, count }) => (
                  <label class="filter-option">
                    <input type="checkbox" value={domain} data-filter="domain" />
                    <span>{domain}</span>
                    <span class="filter-count">{count}</span>
                  </label>
                ))}
              </div>
            </div>
          )
        }

        <a href="/graph" class="clear-filters" id="graph-clear-filters" hidden>
          Clear All Filters
        </a>
      </aside>

      <!-- Graph Canvas -->
      <div class="graph-canvas-container">
        <div class="graph-info">
          Showing <span id="graph-count">{graphData.nodes.length}</span> of {graphData.nodes.length}
          patterns
        </div>

        <div class="graph-canvas" id="graph-canvas">
          <svg width="100%" height="600" viewBox="0 0 800 600" class="graph-svg">
            <defs>
              <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
                <feGaussianBlur stdDeviation="3" result="coloredBlur"></feGaussianBlur>
                <feMerge>
                  <feMergeNode in="coloredBlur"></feMergeNode>
                  <feMergeNode in="SourceGraphic"></feMergeNode>
                </feMerge>
              </filter>
            </defs>

            <g id="graph-viewport">
              <!-- Edges -->
              {
                positionedEdges.map((edge) => (
                  <line
                    x1={edge.x1}
                    y1={edge.y1}
                    x2={edge.x2}
                    y2={edge.y2}
                    stroke="var(--color-border)"
                    stroke-width="2"
                    class="graph-edge"
                    data-edge
                    data-source={edge.source}
                    data-target={edge.target}
                  />
                ))
              }

              <!-- Nodes -->
              {
                positionedNodes.map((node: GraphNode & { x: number; y: number }) => {
                  const categoryColor = getCategoryColor(node.category);

                  return (
                    <g
                      class="graph-node"
                      data-node-id={node.id}
                      data-category={node.category}
                      data-status={node.status}
                      data-tags={(node.tags || []).join('|')}
                      data-maturity={node.maturity || ''}
                      data-domains={(node.domains || []).join('|')}
                      data-summary={node.summary || ''}
                      data-title={node.title}
                      data-slug={node.slug}
                      data-x={node.x}
                      data-y={node.y}
                      transform={`translate(${node.x} ${node.y})`}
                      style="--category-color: {categoryColor}"
                    >
                      <circle
                        cx="0"
                        cy="0"
                        r="24"
                        fill={categoryColor}
                        class="node-circle"
                        data-node-circle={node.id}
                      />
                      <text x="0" y="35" text-anchor="middle" class="node-label">
                        {node.title.length > 30 ? node.title.slice(0, 30) + '...' : node.title}
                      </text>
                      <foreignObject x="-100" y="-120" width="200" height="120" class="node-tooltip">
                        <div xmlns="http://www.w3.org/1999/xhtml">
                          <strong>{node.title}</strong>
                          <span class="tooltip-category">{node.category}</span>
                          <span class="tooltip-status">{node.status}</span>
                          {node.summary && <span class="tooltip-summary">{node.summary}</span>}
                        </div>
                      </foreignObject>
                      <a href={`/graph?node=${node.id}`} class="node-link" data-node-id={node.id}>
                        <circle cx="0" cy="0" r="32" fill="transparent" />
                      </a>
                    </g>
                  );
                })
              }
            </g>
          </svg>
        </div>

        <!-- Detail Panel -->
        <div class="graph-detail-panel" id="graph-detail" hidden>
          <button class="detail-close" id="detail-close">×</button>

          <h2 class="detail-title" id="detail-title"></h2>

          <div class="detail-meta">
            <span class="detail-category" id="detail-category"></span>
            <span class="detail-status" id="detail-status"></span>
          </div>

          <p class="detail-summary" id="detail-summary"></p>

          <div class="detail-badges" id="detail-badges"></div>

          <a href="/patterns" class="detail-link" id="detail-link">View Full Pattern →</a>
        </div>
      </div>
    </div>
  </div>
</BaseLayout>

<script>
  import {
    drag,
    forceCenter,
    forceCollide,
    forceLink,
    forceManyBody,
    forceSimulation,
    select,
    zoom,
  } from 'd3';

  const params = new URLSearchParams(window.location.search);
  const selectedCategories = params.getAll('category');
  const selectedStatuses = params.getAll('status');
  const selectedTags = params.getAll('tag');
  const selectedMaturities = params.getAll('maturity');
  const selectedDomains = params.getAll('domain');
  const selectedNodeId = params.get('node');

  const clearFiltersLink = document.getElementById('graph-clear-filters');
  const countEl = document.getElementById('graph-count');
  const nodeElements = document.querySelectorAll('.graph-node');
  const edgeElements = document.querySelectorAll('[data-edge]');
  const categoryFilters = document.querySelectorAll('input[data-filter="category"]');
  const statusFilters = document.querySelectorAll('input[data-filter="status"]');
  const tagFilters = document.querySelectorAll('input[data-filter="tag"]');
  const maturityFilters = document.querySelectorAll('input[data-filter="maturity"]');
  const domainFilters = document.querySelectorAll('input[data-filter="domain"]');

  const detailPanel = document.getElementById('graph-detail');
  const detailTitle = document.getElementById('detail-title');
  const detailCategory = document.getElementById('detail-category');
  const detailStatus = document.getElementById('detail-status');
  const detailSummary = document.getElementById('detail-summary');
  const detailBadges = document.getElementById('detail-badges');
  const detailLink = document.getElementById('detail-link');
  const detailClose = document.getElementById('detail-close');

  const svg = document.querySelector('.graph-svg');
  const viewport = document.getElementById('graph-viewport');
  const svgSelection = svg ? select(svg) : null;

  const nodes = Array.from(nodeElements)
    .map((node) => ({
      id: node.getAttribute('data-node-id') || '',
      x: Number(node.getAttribute('data-x')) || 400,
      y: Number(node.getAttribute('data-y')) || 300,
    }))
    .filter((node) => node.id);

  const edges = Array.from(edgeElements)
    .map((edge) => ({
      source: edge.getAttribute('data-source'),
      target: edge.getAttribute('data-target'),
    }))
    .filter((edge) => edge.source && edge.target);

  const nodeSelection = svgSelection ? svgSelection.selectAll('.graph-node').data(nodes) : null;
  const edgeSelection = svgSelection ? svgSelection.selectAll('[data-edge]').data(edges) : null;

  if (svgSelection && viewport && nodes.length > 0) {
    const viewBox = svg?.viewBox?.baseVal;
    const width = viewBox?.width || 800;
    const height = viewBox?.height || 600;

    const simulation = forceSimulation(nodes)
      .force('link', forceLink(edges).id((d) => d.id).distance(140).strength(0.25))
      .force('charge', forceManyBody().strength(-240))
      .force('center', forceCenter(width / 2, height / 2))
      .force('collision', forceCollide(42))
      .on('tick', () => {
        edgeSelection
          ?.attr('x1', (d) => d.source.x)
          ?.attr('y1', (d) => d.source.y)
          ?.attr('x2', (d) => d.target.x)
          ?.attr('y2', (d) => d.target.y);

        nodeSelection?.attr('transform', (d) => `translate(${d.x} ${d.y})`);
      });

    let dragMoved = false;
    const dragBehavior = drag()
      .on('start', (event, d) => {
        dragMoved = false;
        if (!event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
      })
      .on('drag', (event, d) => {
        dragMoved = true;
        d.fx = event.x;
        d.fy = event.y;
      })
      .on('end', (event, d) => {
        if (!event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
      });

    if (nodeSelection) {
      nodeSelection.call(dragBehavior).on('click', (event) => {
        if (!dragMoved) return;
        event.preventDefault();
        event.stopPropagation();
        dragMoved = false;
      });
    }

    const zoomBehavior = zoom()
      .scaleExtent([0.5, 2.5])
      .on('zoom', (event) => {
        viewport.setAttribute('transform', event.transform.toString());
      });

    svgSelection.call(zoomBehavior);
  }

  const applyFilters = () => {
    const visibleNodes = new Set();
    nodeElements.forEach((node) => {
      const category = node.getAttribute('data-category') || '';
      const status = node.getAttribute('data-status') || '';
      const tags = (node.getAttribute('data-tags') || '').split('|').filter(Boolean);
      const maturity = node.getAttribute('data-maturity') || '';
      const domains = (node.getAttribute('data-domains') || '').split('|').filter(Boolean);

      let matches = true;
      if (selectedCategories.length > 0 && !selectedCategories.includes(category)) {
        matches = false;
      }
      if (selectedStatuses.length > 0 && !selectedStatuses.includes(status)) {
        matches = false;
      }
      if (selectedTags.length > 0 && !tags.some((tag) => selectedTags.includes(tag))) {
        matches = false;
      }
      if (selectedMaturities.length > 0 && !selectedMaturities.includes(maturity)) {
        matches = false;
      }
      if (
        selectedDomains.length > 0 &&
        !domains.some((domain) => selectedDomains.includes(domain))
      ) {
        matches = false;
      }

      node.style.display = matches ? '' : 'none';
      if (matches) {
        const nodeId = node.getAttribute('data-node-id');
        if (nodeId) visibleNodes.add(nodeId);
      }
    });

    edgeElements.forEach((edge) => {
      const source = edge.getAttribute('data-source');
      const target = edge.getAttribute('data-target');
      const show = source && target && visibleNodes.has(source) && visibleNodes.has(target);
      edge.style.display = show ? '' : 'none';
    });

    if (countEl) {
      countEl.textContent = String(visibleNodes.size);
    }

    if (clearFiltersLink) {
      clearFiltersLink.hidden =
        selectedCategories.length === 0 &&
        selectedStatuses.length === 0 &&
        selectedTags.length === 0 &&
        selectedMaturities.length === 0 &&
        selectedDomains.length === 0;
    }
  };

  const bindFilterGroup = (inputs, paramName, selectedValues) => {
    inputs.forEach((input) => {
      input.checked = selectedValues.includes(input.value);
      input.addEventListener('change', () => {
        const params = new URLSearchParams(window.location.search);
        const values = params.getAll(paramName);
        if (input.checked) {
          values.push(input.value);
        } else {
          const index = values.indexOf(input.value);
          if (index !== -1) values.splice(index, 1);
        }
        params.delete(paramName);
        values.forEach((value) => params.append(paramName, value));
        window.location.search = params.toString();
      });
    });
  };

  const updateFilterInputs = () => {
    bindFilterGroup(categoryFilters, 'category', selectedCategories);
    bindFilterGroup(statusFilters, 'status', selectedStatuses);
    bindFilterGroup(tagFilters, 'tag', selectedTags);
    bindFilterGroup(maturityFilters, 'maturity', selectedMaturities);
    bindFilterGroup(domainFilters, 'domain', selectedDomains);
  };

  const updateDetailPanel = () => {
    if (!detailPanel) return;

    document.querySelectorAll('[data-node-circle]').forEach((circle) => {
      circle.removeAttribute('filter');
    });

    if (!selectedNodeId) {
      detailPanel.hidden = true;
      return;
    }

    const node = document.querySelector(`.graph-node[data-node-id="${selectedNodeId}"]`);
    if (!node) {
      detailPanel.hidden = true;
      return;
    }

    if (node.style.display === 'none') {
      detailPanel.hidden = true;
      return;
    }

    const title = node.getAttribute('data-title') || '';
    const category = node.getAttribute('data-category') || '';
    const status = node.getAttribute('data-status') || '';
    const slug = node.getAttribute('data-slug') || '';
    const summary = node.getAttribute('data-summary') || '';
    const maturity = node.getAttribute('data-maturity') || '';
    const tags = (node.getAttribute('data-tags') || '').split('|').filter(Boolean);
    const domains = (node.getAttribute('data-domains') || '').split('|').filter(Boolean);

    if (detailTitle) detailTitle.textContent = title;
    if (detailCategory) detailCategory.textContent = category;
    if (detailStatus) detailStatus.textContent = status;
    if (detailLink && slug) detailLink.setAttribute('href', `/patterns/${slug}`);
    if (detailSummary) {
      detailSummary.textContent = summary;
      detailSummary.hidden = summary.length === 0;
    }

    if (detailBadges) {
      detailBadges.innerHTML = '';
      const badgeItems: Array<{ label: string; type: string }> = [];
      if (maturity) {
        badgeItems.push({ label: maturity, type: 'maturity' });
      }
      tags.forEach((tag) => badgeItems.push({ label: tag, type: 'tag' }));
      domains.forEach((domain) => badgeItems.push({ label: domain, type: 'domain' }));

      badgeItems.forEach((badge) => {
        const span = document.createElement('span');
        span.className = `detail-badge detail-badge--${badge.type}`;
        span.textContent = badge.label;
        detailBadges.appendChild(span);
      });

      detailBadges.hidden = badgeItems.length === 0;
    }

    if (detailStatus) {
      detailStatus.style.setProperty('--status-color', getStatusColor(status));
    }

    const nodeCircle = document.querySelector(`[data-node-circle="${selectedNodeId}"]`);
    if (nodeCircle) {
      nodeCircle.setAttribute('filter', 'url(#glow)');
    }

    detailPanel.hidden = false;
  };

  const getStatusColor = (status) => {
    const colors = {
      proposed: '#9ca3af',
      emerging: '#60a5fa',
      established: '#34d399',
      'validated-in-production': '#10b981',
      'best-practice': '#059669',
      'experimental-but-awesome': '#f59e0b',
      'rapidly-improving': '#8b5cf6',
    };
    return colors[status] || '#6b7280';
  };

  if (detailClose) {
    detailClose.addEventListener('click', () => {
      window.location.href = '/graph';
    });
  }

  updateFilterInputs();
  applyFilters();
  updateDetailPanel();
</script>

<style>
  .graph-page {
    max-width: 1600px;
    margin: 0 auto;
    padding: var(--spacing-xl) var(--spacing-lg);
  }

  .graph-header {
    text-align: center;
    margin-bottom: var(--spacing-2xl);
  }

  .graph-header h1 {
    font-size: 2.5rem;
    font-weight: 700;
    color: var(--color-text);
    margin-bottom: var(--spacing-md);
  }

  .graph-subtitle {
    font-size: 1.125rem;
    color: var(--color-text-muted);
  }

  .graph-layout {
    display: grid;
    grid-template-columns: 280px 1fr;
    gap: var(--spacing-xl);
  }

  .graph-filters {
    position: sticky;
    top: 100px;
    max-height: calc(100vh - 120px);
    overflow-y: auto;
    padding: var(--spacing-lg);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-lg);
    background-color: var(--color-bg);
  }

  .filter-section {
    margin-bottom: var(--spacing-lg);
  }

  .filter-section:last-child {
    margin-bottom: 0;
  }

  .filter-title {
    font-size: 0.875rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--color-text-muted);
    margin-bottom: var(--spacing-md);
  }

  .filter-options {
    display: flex;
    flex-direction: column;
    gap: var(--spacing-sm);
  }

  .filter-option {
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
    cursor: pointer;
    padding: var(--spacing-xs);
    border-radius: var(--radius-sm);
    transition: background-color 0.2s ease;
  }

  .filter-option:hover {
    background-color: var(--color-border);
  }

  .filter-option input[type='checkbox'] {
    cursor: pointer;
  }

  .filter-option span:first-of-type {
    flex: 1;
    font-size: 0.875rem;
    color: var(--color-text);
  }

  .filter-count {
    font-size: 0.75rem;
    color: var(--color-text-muted);
    background-color: var(--color-border);
    padding: 2px 6px;
    border-radius: 10px;
  }

  .clear-filters {
    display: block;
    width: 100%;
    padding: var(--spacing-sm);
    text-align: center;
    background-color: var(--color-primary);
    color: white;
    text-decoration: none;
    border-radius: var(--radius-md);
    font-size: 0.875rem;
    font-weight: 500;
  }

  .clear-filters:hover {
    background-color: var(--color-primary-dark);
  }

  .graph-canvas-container {
    position: relative;
  }

  .graph-info {
    margin-bottom: var(--spacing-md);
    padding: var(--spacing-md);
    background-color: var(--color-border);
    border-radius: var(--radius-md);
    font-size: 0.875rem;
    color: var(--color-text-muted);
    text-align: center;
  }

  .graph-canvas {
    border: 1px solid var(--color-border);
    border-radius: var(--radius-lg);
    background-color: var(--color-bg);
    overflow: hidden;
  }

  .graph-svg {
    display: block;
    width: 100%;
    height: 100%;
    cursor: grab;
    touch-action: none;
  }

  .graph-svg:active {
    cursor: grabbing;
  }

  .graph-edge {
    opacity: 0.3;
  }

  .graph-node {
    cursor: grab;
  }

  .node-circle {
    stroke: white;
    stroke-width: 2;
    transition: all 0.2s ease;
  }

  .graph-node:hover .node-circle {
    stroke-width: 3;
    filter: drop-shadow(0 0 8px var(--category-color));
  }

  .node-label {
    font-size: 12px;
    fill: var(--color-text);
    pointer-events: none;
  }

  .node-tooltip {
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.2s ease;
  }

  .graph-node:hover .node-tooltip {
    opacity: 1;
  }

  .node-tooltip div {
    padding: var(--spacing-sm);
    background-color: var(--color-bg);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-md);
    font-size: 0.875rem;
    color: var(--color-text);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  }

  .tooltip-category {
    display: block;
    font-size: 0.75rem;
    color: var(--color-text-muted);
    margin-top: var(--spacing-xs);
  }

  .tooltip-status {
    display: block;
    font-size: 0.75rem;
    color: var(--color-primary);
    margin-top: var(--spacing-xs);
  }

  .tooltip-summary {
    display: -webkit-box;
    font-size: 0.75rem;
    color: var(--color-text-muted);
    margin-top: var(--spacing-xs);
    line-height: 1.4;
    -webkit-line-clamp: 3;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }

  .node-link {
    cursor: pointer;
  }

  .graph-detail-panel {
    position: absolute;
    top: 20px;
    right: 20px;
    width: 320px;
    padding: var(--spacing-lg);
    background-color: var(--color-bg);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-lg);
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.1);
    z-index: 10;
  }

  .detail-close {
    position: absolute;
    top: var(--spacing-sm);
    right: var(--spacing-sm);
    width: 32px;
    height: 32px;
    border: none;
    background: transparent;
    font-size: 1.5rem;
    color: var(--color-text-muted);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: var(--radius-sm);
    transition: all 0.2s ease;
  }

  .detail-close:hover {
    background-color: var(--color-border);
    color: var(--color-text);
  }

  .detail-title {
    font-size: 1.25rem;
    font-weight: 600;
    color: var(--color-text);
    margin-bottom: var(--spacing-md);
    padding-right: var(--spacing-lg);
  }

  .detail-meta {
    display: flex;
    flex-wrap: wrap;
    gap: var(--spacing-sm);
    margin-bottom: var(--spacing-lg);
  }

  .detail-summary {
    margin: 0 0 var(--spacing-md);
    color: var(--color-text-muted);
    line-height: 1.6;
  }

  .detail-badges {
    display: flex;
    flex-wrap: wrap;
    gap: var(--spacing-xs);
    margin-bottom: var(--spacing-lg);
  }

  .detail-badge {
    padding: 2px 8px;
    border-radius: var(--radius-sm);
    font-size: 0.75rem;
    background-color: var(--color-border);
    color: var(--color-text-muted);
  }

  .detail-badge--maturity {
    background-color: var(--color-success);
    color: white;
  }

  .detail-badge--domain {
    color: var(--color-text);
  }

  .detail-category,
  .detail-status {
    padding: var(--spacing-xs) var(--spacing-sm);
    border-radius: var(--radius-sm);
    font-size: 0.75rem;
    font-weight: 500;
  }

  .detail-category {
    background-color: var(--color-border);
    color: var(--color-text);
  }

  .detail-status {
    background-color: var(--status-color);
    color: white;
  }

  .detail-link {
    display: inline-block;
    padding: var(--spacing-sm) var(--spacing-lg);
    background-color: var(--color-primary);
    color: white;
    text-decoration: none;
    border-radius: var(--radius-md);
    font-weight: 500;
    transition: background-color 0.2s ease;
  }

  .detail-link:hover {
    background-color: var(--color-primary-dark);
  }

  @media (max-width: 1024px) {
    .graph-layout {
      grid-template-columns: 1fr;
    }

    .graph-filters {
      position: static;
      max-height: none;
    }

    .graph-detail-panel {
      position: static;
      width: 100%;
      margin-top: var(--spacing-lg);
    }
  }

  @media (max-width: 640px) {
    .graph-page {
      padding: var(--spacing-md) var(--spacing-sm);
    }

    .graph-header h1 {
      font-size: 1.75rem;
    }

    .graph-subtitle {
      font-size: 1rem;
    }

    .graph-canvas {
      min-height: 400px;
    }

    .node-circle {
      r: 28 !important;
    }

    .node-link circle {
      r: 36 !important;
    }

    .node-label {
      font-size: 10px;
    }
  }
</style>
