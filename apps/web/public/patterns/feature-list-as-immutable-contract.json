{
  "title": "Feature List as Immutable Contract",
  "status": "emerging",
  "authors": [
    "Nikola Balic (@nibzard)"
  ],
  "based_on": [
    "Anthropic Engineering Team"
  ],
  "category": "Orchestration & Control",
  "source": "https://www.anthropic.com/engineering/effective-harnesses-for-long-running-agents",
  "tags": [
    "scope-control",
    "acceptance-criteria",
    "anti-scope-creep",
    "long-running-agents",
    "task-management"
  ],
  "id": "feature-list-as-immutable-contract",
  "slug": "feature-list-as-immutable-contract",
  "updated_at": "2026-01-05",
  "body": "\n## Problem\n\nLong-running agents exhibit several failure modes when tasked with building complete applications:\n\n- **Premature victory declaration**: Agent declares \"done\" after implementing a fraction of requirements\n- **Scope creep via test deletion**: Agent \"passes\" tests by deleting or weakening them rather than fixing code\n- **Hallucinated completeness**: Agent loses track of what was actually implemented versus planned\n- **Feature drift**: Without a fixed specification, agents may substitute easier features for harder ones\n- **Progress amnesia**: Across sessions, agents forget what's done vs. pending\n\n## Solution\n\nDefine all features upfront in a structured, immutable format that agents can read but cannot meaningfully game:\n\n**1. Comprehensive Feature Specification**\n\nCreate a JSON file with ALL required features before any implementation begins:\n\n```json\n{\n  \"features\": [\n    {\n      \"id\": \"auth-001\",\n      \"category\": \"functional\",\n      \"description\": \"New chat button creates fresh conversation\",\n      \"steps\": [\n        \"Click 'New Chat' button in sidebar\",\n        \"Verify URL changes to new conversation ID\",\n        \"Verify message input is empty and focused\",\n        \"Verify no previous messages are displayed\"\n      ],\n      \"passes\": false\n    },\n    {\n      \"id\": \"auth-002\",\n      \"category\": \"functional\",\n      \"description\": \"User can log out and session is cleared\",\n      \"steps\": [\n        \"Click user profile menu\",\n        \"Click 'Log out' option\",\n        \"Verify redirect to login page\",\n        \"Verify protected routes are inaccessible\"\n      ],\n      \"passes\": false\n    }\n  ]\n}\n```\n\n**2. Immutability Constraints**\n\nEnforce through prompt instructions:\n\n- Agent MAY set `passes: true` after verification\n- Agent MAY NOT delete features from the list\n- Agent MAY NOT modify acceptance criteria/steps\n- Agent MAY NOT mark features as \"not applicable\"\n\n**3. Verification Requirements**\n\nFeatures are only marked passing after:\n\n- Implementation is complete\n- Manual or automated testing confirms all steps pass\n- Agent has actually exercised the feature (not just written code)\n\n```mermaid\ngraph TD\n    A[Feature List Created] --> B[All Features: passes=false]\n    B --> C{Select Next Feature}\n    C --> D[Implement Feature]\n    D --> E[Test Feature]\n    E --> F{All Steps Pass?}\n    F -->|No| D\n    F -->|Yes| G[Set passes=true]\n    G --> H{More Features?}\n    H -->|Yes| C\n    H -->|No| I[Project Complete]\n\n    style A fill:#e1f5fe\n    style I fill:#c8e6c9\n    style G fill:#fff9c4\n```\n\n## How to use it\n\n**Creating effective feature lists:**\n\n- Include 100-200+ features for complex applications\n- Be specific in acceptance criteria (observable behaviors, not implementation details)\n- Group by category (functional, UI, performance, security)\n- Include edge cases and error handling as separate features\n- Write features as a human tester would verify them\n\n**Prompt enforcement:**\n\n```\nCRITICAL RULES:\n1. You MUST NOT delete or modify any feature in feature-list.json\n2. You MUST NOT edit the \"steps\" or \"description\" fields\n3. You MAY ONLY change \"passes\" from false to true\n4. You MUST actually test the feature before marking it passing\n5. If a feature seems impossible, ask the user - do NOT skip it\n```\n\n**Verification tooling:**\n\n- Use browser automation (Puppeteer, Playwright) for E2E verification\n- Run features as a user would, not just unit tests\n- Capture evidence (screenshots, logs) when marking features passing\n\n## Trade-offs\n\n**Pros:**\n\n- Prevents premature victory declaration with clear completion criteria\n- Creates immutable record of requirements that survives session boundaries\n- Makes agent progress measurable (X of Y features passing)\n- Eliminates \"pass by deletion\" attack vector\n- Provides natural work queue for incremental sessions\n\n**Cons:**\n\n- Requires significant upfront investment in feature specification\n- Not suitable for exploratory or research-oriented work\n- May miss emergent requirements discovered during implementation\n- Rigid format doesn't accommodate changing requirements\n- Large feature lists can overwhelm agent context\n\n**When to use:**\n\n- Building complete applications with known requirements\n- Projects spanning many agent sessions\n- When agent accountability is important\n- Replicable workflows (same feature list for multiple similar projects)\n\n**When to avoid:**\n\n- Exploratory prototyping\n- Research tasks with unclear scope\n- Small, single-session tasks\n- Rapidly evolving requirements\n\n## References\n\n* [Anthropic Engineering: Effective Harnesses for Long-Running Agents](https://www.anthropic.com/engineering/effective-harnesses-for-long-running-agents)\n* Related: [Initializer-Maintainer Dual Agent Architecture](initializer-maintainer-dual-agent.md)\n* Related: [Spec-as-Test Feedback Loop](spec-as-test-feedback-loop.md)\n"
}