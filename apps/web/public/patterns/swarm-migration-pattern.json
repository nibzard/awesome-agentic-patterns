{
  "title": "Swarm Migration Pattern",
  "status": "validated-in-production",
  "authors": [
    "Nikola Balic (@nibzard)"
  ],
  "based_on": [
    "Boris Cherny (Anthropic)",
    "Anthropic Internal Users"
  ],
  "category": "Orchestration & Control",
  "source": "https://every.to/podcast/transcript-how-to-use-claude-code-like-the-people-who-built-it",
  "tags": [
    "swarm",
    "map-reduce",
    "migration",
    "parallelization",
    "sub-agents",
    "scalability",
    "framework-migration"
  ],
  "id": "swarm-migration-pattern",
  "slug": "swarm-migration-pattern",
  "updated_at": "2026-01-05",
  "body": "\n## Problem\n\nLarge-scale code migrations are time-consuming when done sequentially:\n\n- **Framework upgrades** (e.g., testing library A → testing library B)\n- **Lint rule rollouts** across hundreds of files\n- **API migrations** when dependencies change\n- **Code modernization** (e.g., class components → hooks)\n- **Refactoring patterns** across the codebase\n\nHumans doing these manually is tedious; single agents doing them sequentially is slow.\n\n## Solution\n\nUse a **swarm architecture** where the main agent orchestrates 10+ parallel subagents working simultaneously on independent chunks of the migration.\n\n**Pattern:**\n\n1. **Main agent creates migration plan**: Enumerate all files/targets needing migration\n2. **Create todo list**: Break work into parallelizable chunks\n3. **Spawn subagent swarm**: Start 10+ agents concurrently, each taking N items\n4. **Map-reduce execution**: Each subagent migrates its chunk independently\n5. **Verification**: Main agent validates results, may spawn additional agents for fixes\n6. **Consolidation**: Combine results (single PR or coordinated merge)\n\n```mermaid\ngraph TD\n    A[Main Agent] --> B[Scan Codebase]\n    B --> C[Create Todo List<br/>100 files need migration]\n    C --> D[Spawn 10 Subagents]\n    D --> E1[Subagent 1<br/>Files 1-10]\n    D --> E2[Subagent 2<br/>Files 11-20]\n    D --> E3[...]\n    D --> E10[Subagent 10<br/>Files 91-100]\n    E1 --> F[Main Agent Verifies]\n    E2 --> F\n    E3 --> F\n    E10 --> F\n    F --> G[Consolidated PR]\n```\n\n## How to use it\n\n**Implementation approach:**\n\n```pseudo\n# Main agent orchestration\nmain_agent.prompt = \"\"\"\n1. Find all files matching pattern (e.g., *.test.js using old framework)\n2. Create todo list with file paths\n3. Divide into batches of 10 files each\n4. For each batch, spawn subagent with instructions:\n   \n- Migrate these specific files\n   - Follow migration guide at docs/migration.md\n   - Run tests after each change\n   - Commit if tests pass\n5. Monitor all subagents\n6. Verify all todos completed\n\"\"\"\n\n# Spawn swarm\nfor batch in batches:\n    spawn_subagent(\n        task=f\"Migrate {batch.files} from Framework A to B\",\n        context=migration_guide,\n        auto_commit=True\n    )\n```\n\n**Real-world usage at Anthropic:**\n\n> \"There's an increasing number of people internally at Anthropic that are using a lot of credits every month. Spending like over a thousand bucks every month. And this percent of people was growing actually pretty fast. The common use case is code migration... The main agent makes a big to-do list for everything and then just kind of map reduces over a bunch of subagents. You instruct Claude like, yeah, start 10 agents and then just go 10 at a time and just migrate all the stuff over.\" —Boris Cherny\n\n**Common migration types:**\n\n- **Lint rule enforcement**: Apply new ESLint/Biome rules across files\n- **Framework migration**: Jest → Vitest, Mocha → Jest, etc.\n- **API updates**: Update to new library versions\n- **Code modernization**: var → const/let, callbacks → async/await\n- **Import path changes**: Relative → absolute paths\n\n## Trade-offs\n\n**Pros:**\n\n- **Massive parallelization**: 10x+ speedup vs. sequential migration\n- **Easy verification**: Each subagent handles tractable chunk\n- **Fault isolation**: One subagent failing doesn't break others\n- **Cost-effective for scale**: $1000 for migrations that would take weeks manually\n- **Reproducible**: Same migration applied consistently across all files\n\n**Cons:**\n\n- **High token cost**: Running 10+ agents simultaneously\n- **Coordination complexity**: Main agent must track all subagents\n- **Merge conflicts**: Parallel changes might conflict\n- **Requires independence**: Only works if migration targets are separable\n- **Verification burden**: Need to validate 10+ agent outputs\n\n**Prerequisites:**\n\n- **Atomic migrations**: Each file can be migrated independently\n- **Clear specification**: Migration rules must be unambiguous\n- **Good test coverage**: Automated verification of correctness\n- **Sandbox environment**: Safe to run many agents simultaneously\n\n**Optimization tips:**\n\n- **Batch size tuning**: Start with 10 files per agent, adjust based on complexity\n- **Staged rollout**: Migrate 10% first, verify, then do the rest\n- **Failure handling**: Have main agent retry failed batches with refined instructions\n- **Resource limits**: Cap parallel agents to avoid overwhelming infrastructure\n\n## References\n\n* Boris Cherny: \"There's an increasing number of people internally at Anthropic using a lot of credits every month. Spending over a thousand bucks. The common use case is code migration. Framework A to framework B. The main agent makes a big to-do list for everything and map reduces over a bunch of subagents. Start 10 agents and go 10 at a time and migrate all the stuff over.\"\n* Boris Cherny: \"Lint rules... there's some kind of lint rule you're rolling out, there's no auto fixer because static analysis can't really—it's too simplistic for it. Framework migrations... we just migrated from one testing framework to a different one. That's a pretty common one where it's super easy to verify the output.\"\n* [AI & I Podcast: How to Use Claude Code Like the People Who Built It](https://every.to/podcast/transcript-how-to-use-claude-code-like-the-people-who-built-it)\n"
}