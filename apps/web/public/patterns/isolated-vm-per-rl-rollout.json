{
  "title": "Isolated VM per RL Rollout",
  "status": "emerging",
  "authors": [
    "Nikola Balic (@nibzard)"
  ],
  "based_on": [
    "Sam Pretty (Cognition)",
    "Devon Engineering Team"
  ],
  "category": "Security & Safety",
  "source": "https://youtu.be/1s_7RMG4O4U",
  "tags": [
    "isolation",
    "security",
    "reinforcement-learning",
    "infrastructure",
    "state-management",
    "agent-rft"
  ],
  "id": "isolated-vm-per-rl-rollout",
  "slug": "isolated-vm-per-rl-rollout",
  "updated_at": "2026-01-05",
  "body": "\n## Problem\n\nDuring reinforcement learning training with tool-using agents, multiple rollouts execute simultaneously and may call destructive or stateful tools:\n\n- **Cross-contamination**: One rollout's actions affect another rollout's environment\n- **Destructive commands**: Agent might run `rm -rf`, corrupting shared state\n- **State leakage**: File system changes persist across rollouts, creating inconsistent training data\n- **Reward corruption**: If rollout B sees rollout A's side effects, reward signals become meaningless\n- **Debugging nightmares**: Non-deterministic failures due to race conditions\n\nCognition faced this when training Devon's file planning agent: the agent had access to a `shell` tool that could run arbitrary commands like `grep`, `find`, or even `rm`. Running 32 parallel rollouts on shared infrastructure would cause chaos.\n\n## Solution\n\n**Spin up an isolated virtual machine (or container) for each RL rollout, ensuring complete environment isolation.**\n\n**Architecture:**\n\n1. **Rollout ID Tracking**: OpenAI's Agent RFT platform assigns unique IDs to each rollout\n2. **VM/Container Mapping**: Your infrastructure maps rollout ID → dedicated VM\n3. **Clean State**: Each VM starts fresh with identical filesystem, packages, and configuration\n4. **Cleanup**: VMs are destroyed after rollout completes (success or failure)\n\n**Key Components:**\n\n- **VM Provisioning**: Fast VM creation (typically cloud instances or containers)\n- **Bursty Scaling**: Handle 100s-500s of simultaneous VM requests at training step boundaries\n- **State Isolation**: No shared filesystems or databases between VMs\n- **Timeout Handling**: VMs auto-destroy after timeout to prevent resource leaks\n\n```python\n# Infrastructure setup (Cognition's approach)\nfrom modal import Image, App, method\nimport uuid\n\n# Base VM image with all dependencies\nbase_image = (\n    Image.debian_slim()\n    .apt_install(\"git\", \"build-essential\")\n    .pip_install(\"pandas\", \"numpy\", \"openai\")\n    .copy_local_dir(\"./corpus\", \"/workspace/corpus\")  # Training data\n)\n\napp = App(\"agent-rft-tool-server\")\n\n@app.cls(\n    image=base_image,\n    cpu=2,\n    memory=4096,\n    timeout=600,  # 10 min per rollout max\n)\nclass IsolatedToolExecutor:\n    \"\"\"\n    Each instance gets its own isolated VM\n    Spun up per-rollout during RL training\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize fresh state for this rollout\"\"\"\n        self.rollout_id = None\n        self.workspace = \"/workspace\"\n        self.history = []\n\n    @method()\n    def initialize_rollout(self, rollout_id: str):\n        \"\"\"\n        Called first when rollout starts\n        Sets up isolated state for this specific rollout\n        \"\"\"\n        self.rollout_id = rollout_id\n        print(f\"[{rollout_id}] Initialized isolated VM\")\n\n        # Create isolated working directory\n        import os\n        self.work_dir = f\"{self.workspace}/rollout_{rollout_id}\"\n        os.makedirs(self.work_dir, exist_ok=True)\n\n        return {\"status\": \"ready\", \"rollout_id\": rollout_id}\n\n    @method()\n    def execute_shell(self, rollout_id: str, command: str):\n        \"\"\"\n        Execute shell command in isolated environment\n        Safe because this VM is dedicated to this rollout\n        \"\"\"\n        if rollout_id != self.rollout_id:\n            raise ValueError(f\"Rollout ID mismatch: {rollout_id} != {self.rollout_id}\")\n\n        import subprocess\n\n        print(f\"[{rollout_id}] Executing: {command}\")\n\n        # Even destructive commands are safe in isolated VM\n        result = subprocess.run(\n            command,\n            shell=True,\n            cwd=self.work_dir,\n            capture_output=True,\n            text=True,\n            timeout=60\n        )\n\n        self.history.append({\n            \"command\": command,\n            \"returncode\": result.returncode,\n            \"stdout\": result.stdout[:1000],  # Limit output\n            \"stderr\": result.stderr[:1000]\n        })\n\n        return {\n            \"stdout\": result.stdout,\n            \"stderr\": result.stderr,\n            \"returncode\": result.returncode\n        }\n\n    @method()\n    def read_file(self, rollout_id: str, filepath: str):\n        \"\"\"Read file from corpus or workspace\"\"\"\n        if rollout_id != self.rollout_id:\n            raise ValueError(f\"Rollout ID mismatch\")\n\n        # Files are isolated to this VM\n        full_path = f\"{self.workspace}/{filepath}\"\n\n        try:\n            with open(full_path, 'r') as f:\n                content = f.read()\n            return {\"content\": content, \"error\": None}\n        except Exception as e:\n            return {\"content\": None, \"error\": str(e)}\n\n    @method()\n    def search_corpus(self, rollout_id: str, query: str):\n        \"\"\"Semantic search over documents\"\"\"\n        if rollout_id != self.rollout_id:\n            raise ValueError(f\"Rollout ID mismatch\")\n\n        # Search implementation here...\n        # Corpus is read-only, copied into VM at startup\n\n        return {\"results\": [...]}\n\n    @method()\n    def cleanup(self, rollout_id: str):\n        \"\"\"\n        Optional cleanup (Modal handles VM destruction automatically)\n        \"\"\"\n        print(f\"[{rollout_id}] Rollout complete, VM will be destroyed\")\n        return {\"history\": self.history}\n\n\n# Tool endpoint configuration for OpenAI Agent RFT\ntools_config = [\n    {\n        \"name\": \"shell\",\n        \"url\": \"https://your-app.modal.run/execute_shell\",\n        \"headers\": {\"Authorization\": \"Bearer YOUR_TOKEN\"}\n    },\n    {\n        \"name\": \"read_file\",\n        \"url\": \"https://your-app.modal.run/read_file\",\n        \"headers\": {\"Authorization\": \"Bearer YOUR_TOKEN\"}\n    },\n    {\n        \"name\": \"search\",\n        \"url\": \"https://your-app.modal.run/search_corpus\",\n        \"headers\": {\"Authorization\": \"Bearer YOUR_TOKEN\"}\n    }\n]\n```\n\n**Request Flow:**\n\n```mermaid\nsequenceDiagram\n    participant OAI as OpenAI Training\n    participant LB as Load Balancer\n    participant VM1 as VM (Rollout 1)\n    participant VM2 as VM (Rollout 2)\n\n    Note over OAI: Training Step Starts\n    OAI->>LB: Rollout 1: shell(\"grep TODO\")\n    OAI->>LB: Rollout 2: shell(\"rm temp.txt\")\n\n    LB->>VM1: Route to isolated VM 1\n    LB->>VM2: Route to isolated VM 2\n\n    Note over VM1: Executes grep TODO<br/>(safe, isolated)\n    Note over VM2: Executes rm temp.txt<br/>(safe, isolated)\n\n    VM1->>LB: grep results\n    VM2->>LB: success\n\n    LB->>OAI: Return results\n\n    Note over VM1,VM2: Rollouts complete<br/>VMs destroyed\n```\n\n## How to use it\n\n**Phase 1: Infrastructure Setup**\n\nChoose your isolation technology:\n\n- **Modal/Lambda**: Serverless functions with container isolation (easiest)\n- **Docker**: Containers per rollout (good balance)\n- **Cloud VMs**: EC2/GCP instances per rollout (maximum isolation, slower)\n- **Kubernetes Jobs**: K8s pods per rollout (production-grade)\n\n**Phase 2: Implement Rollout ID Tracking**\n\n```python\n# All tool endpoints must accept and validate rollout_id\n@app.post(\"/tool/{tool_name}\")\nasync def execute_tool(tool_name: str, rollout_id: str, params: dict):\n    # Get or create isolated environment for this rollout\n    vm = get_or_create_vm(rollout_id)\n\n    # Execute in isolated context\n    result = vm.execute(tool_name, params)\n\n    return result\n```\n\n**Phase 3: Handle Bursty Traffic**\n\nAgent RFT sends traffic in bursts:\n\n- **Training step boundary**: 100-500 simultaneous rollout requests\n- **Tool call latency**: Brief pauses while agent thinks\n- **Cleanup phase**: Mass VM destruction\n\nConfigure auto-scaling:\n\n```python\n# Modal example\n@app.cls(\n    image=base_image,\n    concurrency_limit=500,  # Max concurrent VMs\n    container_idle_timeout=60,  # Cleanup after 1 min idle\n)\n```\n\n**Phase 4: Monitor Infrastructure**\n\nCritical metrics:\n\n- **VM provisioning time**: Should be <5 seconds\n- **Failure rate**: Infrastructure errors → zero reward → training collapse\n- **Resource leaks**: VMs not cleaning up properly\n- **Cost**: 500 VMs * training duration can get expensive\n\nSam's advice from Cognition:\n\n> \"Sometimes like let's say there's infrastructure error and the VMs fail... that does lead to the training kind of collapsing because even the model might have done something good, it got a zero reward.\"\n\n**Set up monitoring:**\n\n```python\nimport logging\n\nlogger = logging.getLogger(\"rollout-infra\")\n\n@method()\ndef execute_tool(self, rollout_id: str, tool: str, params: dict):\n    try:\n        result = self._execute(tool, params)\n\n        # Log success\n        logger.info(f\"rollout={rollout_id} tool={tool} status=success\")\n\n        return result\n\n    except Exception as e:\n        # Log failure - critical for debugging training collapse\n        logger.error(\n            f\"rollout={rollout_id} tool={tool} status=error error={str(e)}\"\n        )\n\n        # Return error to model (don't give zero reward for infra issues)\n        return {\n            \"error\": \"Infrastructure error, please retry\",\n            \"retryable\": True\n        }\n```\n\n## Real-World Example: Cognition Devon\n\n**Challenge**: Train Devon's file planning agent with shell tool access\n\n**Requirements:**\n\n- Agent uses `shell` tool to run `grep`, `find`, `ls`, etc.\n- Need to prevent one rollout from affecting others\n- Must handle potentially destructive commands safely\n\n**Solution:**\n\n1. **Modal Infrastructure**: Used Modal for fast VM provisioning\n2. **Isolation**: Each rollout gets dedicated VM with fresh filesystem\n3. **Corpus Replication**: Copied entire repository corpus into each VM\n4. **Scaling**: Handled 500+ simultaneous VMs during training bursts\n\n**Results:**\n\n- Safe training despite shell access\n- No cross-contamination between rollouts\n- Deterministic behavior for reward calculation\n- Successfully trained agent to reduce planning from 8-10 tool calls → 4 tool calls\n\n**Infrastructure Lessons Learned:**\n\n- **Bursty traffic is real**: \"At the beginning of every rollout they would send us like 500 new rollout requests\"\n- **Monitor failures**: Infrastructure errors causing zero rewards can collapse training\n- **Reuse production code**: \"We use VMs because we could reuse the production Devon VM info\"\n\n## Trade-offs\n\n**Pros:**\n\n- **Complete isolation**: No cross-contamination between rollouts\n- **Safety**: Destructive commands can't affect other rollouts or host system\n- **Determinism**: Consistent environment for reliable reward signals\n- **Production parity**: Can use exact same environment as production\n\n**Cons:**\n\n- **Cost**: 100s of VMs running simultaneously can be expensive\n- **Provisioning time**: VM startup adds latency (containers are faster)\n- **Complexity**: Requires robust infrastructure and monitoring\n- **Scaling limits**: Cloud provider quotas may limit concurrent VMs\n- **Failure modes**: Infrastructure issues can cause training collapse\n\n## Alternatives\n\n**Shared Infrastructure with Namespacing:**\n\n- Use filesystem namespacing (chroot, Docker volumes)\n- Cheaper but less isolation\n- Risk of leakage through shared resources\n\n**Database-Backed State:**\n\n- Store state in database keyed by rollout ID\n- Simpler infrastructure\n- Doesn't work for filesystem-based tools\n\n**Optimistic Isolation:**\n\n- Let rollouts share infrastructure\n- Detect and discard contaminated rollouts\n- Wastes compute on discarded rollouts\n\n## References\n\n- [OpenAI Build Hour: Agent RFT - Cognition Case Study (November 2025)](https://youtu.be/1s_7RMG4O4U)\n- [Modal Documentation](https://modal.com/docs)\n- [Docker Isolation Best Practices](https://docs.docker.com/engine/security/)\n- Related patterns: Agent Reinforcement Fine-Tuning, Virtual Machine Operator Agent\n"
}