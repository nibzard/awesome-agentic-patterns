{
  "title": "Hybrid LLM/Code Workflow Coordinator",
  "status": "proposed",
  "authors": [
    "Nikola Balic (@nibzard)"
  ],
  "based_on": [
    "Will Larson (Imprint)"
  ],
  "category": "Orchestration & Control",
  "source": "https://lethain.com/agents-coordinators/",
  "tags": [
    "hybrid",
    "llm-driven",
    "code-driven",
    "coordinator",
    "determinism",
    "workflow-orchestration",
    "progressive-enhancement"
  ],
  "id": "hybrid-llmcode-workflow-coordinator",
  "slug": "hybrid-llm-code-workflow-coordinator",
  "updated_at": "2026-01-13",
  "body": "\n## Problem\n\nLLM-driven workflows are **non-deterministic**—even well-crafted prompts can produce unpredictable results. For some tasks (e.g., adding emoji to Slack messages based on PR status), occasional errors are unacceptable. But LLM workflows are fast to prototype and work well for many cases. You need both: **flexibility when experimenting** and **determinism when it matters**.\n\n## Solution\n\nSupport both LLM-driven and code-driven workflows via a **configurable coordinator** parameter. Start with LLM for rapid prototyping, then migrate to code when you need determinism.\n\n**Coordinator configuration:**\n\n```yaml\n# LLM-driven (default, fastest to iterate)\ncoordinator: llm\n\n# Code-driven (deterministic, goes through code review)\ncoordinator: script\ncoordinator_script: scripts/pr_merged.py\n```\n\n**When `coordinator: llm`:**\n- Handler selects configuration based on trigger\n- Loads prompt, tools, virtual files\n- LLM decides which tools to call\n- Handler coordinates tool calls based on LLM responses\n\n**When `coordinator: script`:**\n- Custom Python script controls workflow\n- Same access to tools, trigger data, virtual files as LLM\n- Can invoke LLM via subagent tool when explicitly needed\n- Goes through code review like any other software\n\n**Progressive enhancement approach:**\n\n1. **Start with LLM** - Fast to prototype, works for many cases\n2. **Observe failures** - Track where non-determinism causes problems\n3. **Rewrite to script** - Use Claude Code to one-shot rewrite prompt → code\n4. **Ship with confidence** - Code goes through review, deterministic behavior\n\n```mermaid\ngraph LR\n    A[Trigger] --> B{Coordinator Type}\n    B -->|llm| C[LLM Orchestrates]\n    B -->|script| D[Script Orchestrates]\n    C --> E[Tool Calls]\n    D --> E\n    D -.optional.-> F[Subagent LLM]\n    E --> G[Result]\n\n    style C fill:#e3f2fd,stroke:#1976d2,stroke-width:2px\n    style D fill:#e8f5e9,stroke:#388e3c,stroke-width:2px\n```\n\n## How to use it\n\n**Implementation:**\n\n```python\n# Handler that supports both coordinators\ndef execute_workflow(trigger, config):\n    if config.get(\"coordinator\") == \"script\":\n        # Code-driven: deterministic, goes through review\n        script = config[\"coordinator_script\"]\n        return run_python_script(script, trigger)\n    else:\n        # LLM-driven: flexible, fast iteration\n        prompt = load_prompt(config[\"prompt\"])\n        tools = load_tools(config[\"tools\"])\n        return llm_orchestrate(trigger, prompt, tools)\n```\n\n**Script has same capabilities as LLM:**\n\n```python\n# scripts/pr_merged.py\ndef handler(trigger, tools, virtual_files, subagent):\n    # Same tools, trigger data, virtual files as LLM\n    messages = tools.slack.get_messages(limit=10)\n\n    pr_urls = extract_pr_urls(messages)\n    statuses = [tools.github.get_status(url) for url in pr_urls]\n\n    for msg, status in zip(messages, statuses):\n        if status in [\"merged\", \"closed\"]:\n            tools.slack.add_reacji(msg, \"merged\")\n\n    # Can use LLM selectively if needed\n    # summary = subagent.summarize(statuses)\n```\n\n**When to use each:**\n\n| Use **LLM-driven** when... | Use **Code-driven** when... |\n|----------------------------|----------------------------|\n| Prototyping new workflow | Errors are unacceptable |\n| Logic may change frequently | Determinism required |\n| Happy to tolerate occasional failures | Workflow is stable |\n| Fast iteration matters | Need code review process |\n\n**Migration path:**\n\n1. Prototype with `coordinator: llm`\n2. Deploy and observe failure modes\n3. When failures are problematic, ask Claude Code: \"Rewrite this workflow as a script\"\n4. Update config to `coordinator: script`\n5. PR goes through review, merge with confidence\n\n## Trade-offs\n\n**Pros:**\n\n- **Best of both worlds**: LLM flexibility when prototyping, code determinism when mature\n- **Easy migration**: One-shot rewrite from prompt → script\n- **Same capabilities**: Scripts have access to all tools, can still use LLM via subagent\n- **Code review**: Critical workflows go through standard review process\n- **Progressive enhancement**: Don't over-engineer from the start\n\n**Cons:**\n\n- **Two code paths**: Need to maintain both LLM and script handlers\n- **Rewrite cost**: Time investment to migrate from LLM → script\n- **Less dynamic**: Scripts are harder to change than prompts\n\n**When NOT to use:**\n\n- Purely deterministic tasks (just use code from start)\n- Highly exploratory tasks where LLM is always needed\n\n## References\n\n* [Building an internal agent: Code-driven vs LLM-driven workflows](https://lethain.com/agents-coordinators/) - Will Larson (Imprint, 2025)\n* Related: Code Mode MCP Tool Interface, Deterministic Security Scanning Build Loop\n"
}