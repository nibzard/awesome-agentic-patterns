{
  "title": "Sub-Agent Spawning",
  "status": "validated-in-production",
  "authors": [
    "Nikola Balic (@nibzard)"
  ],
  "based_on": [
    "Quinn Slack",
    "Thorsten Ball",
    "Will Larson (lethain.com)"
  ],
  "category": "Orchestration & Control",
  "source": "https://www.nibzard.com/ampcode",
  "tags": [
    "orchestration",
    "context",
    "scalability",
    "subagents",
    "yaml-configuration",
    "virtual-files"
  ],
  "slug": "sub-agent-spawning",
  "id": "sub-agent-spawning",
  "summary": "TODO: Add a concise summary for \"Sub-Agent Spawning\" describing the pattern's purpose and key benefits.",
  "updated_at": "2026-01-13",
  "body": "\n## Problem\n\nLarge multi-file tasks blow out the main agent's context window and reasoning budget. You need a way to delegate work to specialized agents with isolated contexts and tools.\n\n## Solution\n\nLet the main agent **spawn focused sub-agents**, each with its own fresh context, to work in parallel on shardable subtasks. Aggregate their results when done.\n\n**Implementation approaches:**\n\n### 1. Declarative YAML Configuration\n\nDefine subagent types in configuration files with their own system prompts, allowed tools, and context windows:\n\n```yaml\n# subagents/planning.yaml\nname: planning\nsystem_prompt: \"Break down complex tasks into steps...\"\ntools:\n  - list_files\n  - read_file\n  # or inherit: all (from parent agent)\n\n# subagents/think.yaml\nname: think\nsystem_prompt: \"Analyze and refine reasoning...\"\ntools:\n  - read_file\n  - search\n```\n\nAgents invoke subagents via a dedicated tool:\n\n```pseudo\nsubagent(agent_name, prompt, files)\n```\n\nThis allows:\n- **Virtual file isolation**: Subagent only sees files explicitly passed to it\n- **Tool scoping**: Subagents can inherit all parent tools or use a subset\n- **Specialized system prompts**: Each subagent type has predefined behavior\n\n### 2. Dynamic Spawning\n\nSpawn subagents on-demand for parallel task execution:\n\n```pseudo\n# Main agent creates todo list\nfiles = glob(\"**/*.md\")\nbatches = chunk(files, 9)\n\n# Spawn subagents for each batch\nfor batch in batches:\n    spawn_subagent(\n        task=\"Update YAML front-matter in these files\",\n        files=batch,\n        context=instructions\n    )\n```\n\nRecent developments show that improved agent [state externalization capabilities](proactive-agent-state-externalization.md) may make subagent delegation more practical by helping agents better identify which tasks are suitable for delegation and how to communicate necessary context to subagents.\n\n## Example (YAML front-matter refactor)\n```mermaid\nsequenceDiagram\n  MainAgent->>GlobTool: \"*.md\"\n  MainAgent->>TaskTool: spawn 4 sub-agents with 9 files each\n  loop per SubAgent\n      SubAgent->>Files: update front-matter\n      SubAgent->>Git: commit\n  end\n  MainAgent->>Git: merge branches âžœ single PR\n```\n\n## How to use it\n\n**Use cases for subagents:**\n\n1. **Context window management**: Process large files in subagents without polluting main context\n   - Upload files to subagent\n   - Extract specific data\n   - Return summary to main agent\n\n2. **Concurrent work**: Run multiple subagents in parallel, join on completion\n   - Reduces clock-time for I/O-bound workflows\n   - Network API calls can happen simultaneously\n\n3. **Code-driven LLM invocation**: Hand off control to LLM for specific determination\n   - Code workflow calls subagent\n   - Subagent makes LLM-powered decision\n   - Control returns to code with result\n\n4. **Security isolation**: Separate tools/contexts in mutually isolated subagents\n   - External resource retrieval isolated from internal access\n   - Reduced blast radius for sensitive operations\n\n**Declarative subagent setup:**\n\n```yaml\n# agents.yaml\nsubagents:\n  planning:\n    file: subagents/planning.yaml\n    allowed_in:\n      - main_agent\n      - research_agent\n\n  think:\n    file: subagents/think.yaml\n    allowed_in:\n      - main_agent\n```\n\n**Virtual file passing:**\n\n```pseudo\n# Main agent\nresult = subagent(\n    agent_name=\"planning\",\n    prompt=\"Analyze these files and create migration plan\",\n    files=[\"file1.ts\", \"file2.ts\", \"file3.ts\"]\n)\n# Only these 3 files visible to planning subagent\n```\n\n**Recursive architecture insight:**\n\nSome implementations treat every agent as a subagent, enabling flexible composition and consistent behavior across the system.\n\n## Advanced usage: Swarm migrations\n\nFor massive parallelization (10+ subagents), see the **Swarm Migration Pattern** which extends this concept for large-scale code migrations.\n\n**High-volume use case at Anthropic:**\n\nUsers spending $1000+/month on Claude Code are typically running swarm migrations:\n\n- Main agent creates comprehensive todo list\n- Spawns 10+ parallel subagents\n- Each handles batch of migration targets (e.g., 10 files)\n- Common for framework migrations, lint rule rollouts, API updates\n- Achieves 10x+ speedup vs. sequential execution\n\n**Quote from Boris Cherny (Anthropic):**\n\n> \"There's an increasing number of people internally at Anthropic using a lot of credits every month. Spending over a thousand bucks. The common use case is code migration... The main agent makes a big to-do list for everything and map reduces over a bunch of subagents. You instruct Claude like start 10 agents and then just go 10 at a time and just migrate all the stuff over.\"\n\n## Trade-offs\n\n**Pros:**\n\n- **Context isolation**: Each subagent has clean context window\n- **Parallelization**: Reduce workflow latency through concurrent execution\n- **Specialization**: Different subagent types for different tasks (planning, thinking, analysis)\n- **Virtual files**: Precise control over what each subagent can see\n- **Tool scoping**: Limit subagent capabilities for security/simplicity\n- **Declarative config**: Reusable subagent definitions via YAML\n\n**Cons:**\n\n- **Overhead**: Spawning and coordinating subagents adds complexity\n- **Cost**: Running multiple agents simultaneously increases token usage\n- **Coordination**: Main agent must track and aggregate subagent results\n- **Not always necessary**: Author notes \"frequently thought we needed subagents, then found more natural alternative\"\n- **Latency visibility**: User-facing latency is \"invisible feature\" until it becomes problematic\n\n**When subagents matter most:**\n\n- Context window management (large file processing)\n- I/O-bound workflows (network API calls)\n- Code-driven workflows needing LLM delegation\n- Massive parallelization needs (10+ concurrent agents)\n\n## References\n\n* Raising An Agent - Episode 6: Claude 4 Sonnet edits 36 blog posts via four sub-agents.\n* Boris Cherny (Anthropic) on swarm migrations for framework changes and lint rules\n* [AI & I Podcast: How to Use Claude Code Like the People Who Built It](https://every.to/podcast/transcript-how-to-use-claude-code-like-the-people-who-built-it)\n* [Cognition AI: Devin & Claude Sonnet 4.5](https://cognition.ai/blog/devin-sonnet-4-5-lessons-and-challenges) - discusses how improved model judgment about state externalization may make subagent delegation more practical\n* [Building Companies with Claude Code](https://claude.com/blog/building-companies-with-claude-code) - Ambral's \"robust research engine\" uses dedicated sub-agents specialized for different data types, enabling parallel research across system areas\n* [Building an internal agent: Subagent support](https://lethain.com/agents-subagents/) - Will Larson on YAML-configured subagents with virtual file isolation and code-driven LLM invocation\n\n[Source](https://www.nibzard.com/ampcode)\n"
}