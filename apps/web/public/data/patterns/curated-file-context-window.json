{
  "title": "Curated File Context Window",
  "status": "best-practice",
  "authors": [
    "Nikola Balic (@nibzard)"
  ],
  "based_on": [
    "Internal AI Dev Team"
  ],
  "category": "Context & Memory",
  "source": "Internal Practice",
  "tags": [
    "code-context",
    "file-scope",
    "relevance",
    "memory-management"
  ],
  "slug": "curated-file-context-window",
  "id": "curated-file-context-window",
  "summary": "TODO: Add a concise summary for \"Curated File Context Window\" describing the pattern's purpose and key benefits.",
  "updated_at": "2026-01-05",
  "body": "\n## Problem\n\nA coding agent often needs to reason about multiple source files, but dumping **all** files into its prompt:\n\n- Quickly exceeds token limits or inference budget.\n- Introduces noise: unrelated files (e.g., tests for other modules, assets, docs) distract the agent.\n- Makes the agent's output slower and less focused on the immediate coding task.\n\n## Solution\n\nMaintain a **sterile, curated \"main\" context window** containing only the code files directly relevant to the current task, and let **helper sub-agents** gather and rank additional files without polluting the main context:\n\n**1. Identify Primary Files**\n- At task kickoff, the agent selects the set of files where changes are intended (e.g., the module under refactoring or feature implementation).\n- Load only those files (plus any explicit dependencies) into the **Main Context Window**.\n\n**2. Spawn a File-Search Sub-Agent**\n- The sub-agent runs a quick search (e.g., `rg` or simple AST heuristics) over the entire repository for symbols, imports, or keywords related to the task.\n- It returns a ranked list of file paths (e.g., \"UserController.java,\" \"UserService.kt,\" \"models/user.rs\").\n\n**3. Fetch & Summarize Secondary Files**\n- For each top-N file (e.g., N = 5), load a brief **summary** or only relevant function/class definitions instead of the full file.\n- Append those summaries (or extracted code snippets) to the **Main Context Window** if they pass a relevance threshold (e.g., share ≥50% of symbols with the task).\n\n**4. Proceed with Coding Task**\n- With a compact, high‐signal context, the agent generates or refactors code, focusing solely on the curated set.\n\nThis ensures that the agent has precisely the files it needs (no more, no less), keeps inference costs low, and improves accuracy by removing irrelevant noise.\n\n## How to use it\n\n- **Initialization:**\n  1. Agent receives a natural-language or structured request (e.g., \"Add validation to `signup()` in `UserController.java`\").\n  2. Automatically parse the request to identify \"primary files\" (`UserController.java`).\n\n- **Sub-Agent Workflow:**\n  1. Invoke a **Search Sub-Agent** via a shell command (e.g., `rg \"signup\" -tjava`) or a lightweight index lookup.\n  2. For each matched file, run a snippet extraction (e.g., parse only method signatures or classes referencing `User`).\n  3. Pass those snippets back to the main agent; filter for purely relevant code (ignore long comments or unrelated class definitions).\n\n- **Context Assembly:**\n  - Construct the final prompt:\n    ```\n    ### PRIMARY FILE: UserController.java\n    (full contents here)\n\n    ### CONTEXT SNIPPETS:\n    \n- UserService.java: validateUser(...)\n    - SignupDTO.java: fields + annotations\n    - ...\n    ```\n\n## Trade-offs\n\n- **Pros:**\n  - Keeps the agent's prompt size **minimum** and directly on-target.\n  - Improves response time and reduces hallucinations from irrelevant code.\n  - Scales to large repositories because only a handful of files are ever loaded.\n\n- **Cons/Considerations:**\n  - Requires maintaining a simple file-search service (e.g., `ripgrep` or an indexed AST).\n  - May miss edge cases if the sub-agent's ranking heuristic is suboptimal—critical files can be omitted.\n  - If the repository structure changes rapidly, the sub-agent's index must stay up-to-date.\n\n## References\n\n- Inspired by \"Curated Context Window\" from Claude Code best practices; adapted for coding-agent workflows.\n- Common practice seen in large-scale monorepo code assistants (e.g., Lyft's internal code AI).\n"
}