{
  "title": "Progressive Autonomy with Model Evolution",
  "status": "best-practice",
  "authors": ["Nikola Balic (@nibzard)"],
  "based_on": ["Boris Cherny (Anthropic)", "Claude Code Team"],
  "category": "Orchestration & Control",
  "source": "https://every.to/podcast/transcript-how-to-use-claude-code-like-the-people-who-built-it",
  "tags": [
    "model-evolution",
    "scaffolding",
    "autonomy",
    "system-prompts",
    "capabilities",
    "model-intelligence"
  ],
  "slug": "progressive-autonomy-with-model-evolution",
  "id": "progressive-autonomy-with-model-evolution",
  "summary": "TODO: Add a concise summary for \"Progressive Autonomy with Model Evolution\" describing the pattern's purpose and key benefits.",
  "updated_at": "2026-01-05",
  "body": "\n## Problem\n\nAgent scaffolding built for older models becomes unnecessary overhead as models improve:\n\n- **Prompt bloat**: System prompts accumulate instructions that newer models don't need\n- **Over-engineered flows**: Complex orchestration for tasks models can now handle directly\n- **Wasted tokens**: Paying for instructions the model already knows\n- **Slower execution**: Unnecessary steps add latency\n- **Maintenance burden**: More code to maintain for diminishing benefit\n\nModels improve faster than scaffolding is removed, creating technical debt.\n\n## Solution\n\n**Actively remove scaffolding** as models become more capable. Regularly audit system prompts, orchestration logic, and agent architecture to eliminate what newer models have internalized.\n\n**Core principle**: Push complexity into the model itself rather than external scaffolding.\n\n```mermaid\ngraph LR\n    A[Model v1] --> B[Needs Scaffolding]\n    B --> C[Complex System Prompts]\n    C --> D[Model v2 Released]\n    D --> E[Remove Unnecessary Instructions]\n    E --> F[Simpler, Faster Agent]\n    F --> G[Model v3 Released]\n    G --> H[Further Simplification]\n```\n\n**Example evolution:**\n\n```pseudo\n# Claude Opus 4.1 (older model)\nsystem_prompt = \"\"\"\nWhen writing code:\n1. First check if file exists\n2. Read current contents\n3. Plan your changes\n4. Make minimal edits\n5. Verify syntax\n... [2000 more tokens of instructions]\n\"\"\"\n\n# Claude Sonnet 4.5 (newer model)\nsystem_prompt = \"\"\"\nWrite clean, tested code.\n\"\"\"  # Model already knows the steps\n```\n\n## How to use it\n\n**Regular audit process:**\n\n1. **Track model releases**: Note when new models become available\n2. **Test simplified prompts**: Remove instructions and see if quality degrades\n3. **Measure token usage**: Quantify savings from prompt reduction\n4. **A/B test scaffolding**: Compare outcomes with and without orchestration steps\n5. **Delete what works**: If model performs equally without scaffolding, remove it\n\n**What to look for:**\n\n- Instructions that are \"obvious\" to humans (likely obvious to advanced models)\n- Multi-step workflows models now handle in one turn\n- Error-handling that models build in automatically\n- Format specifications models infer from context\n- Planning steps models do internally with extended thinking\n\n**Real example from Claude Code:**\n\n> \"I just deleted like 2,000 tokens or something from the system prompt yesterday. Just because Sonnet 4.5 doesn't need it anymore. But Opus 4.1 did need it.\" —Boris Cherny\n\n**Boundary evolution:**\n\n> \"The boundary changes with every model in a surprising way, where the newer models, they're more intelligent. So the boundary of what you need plan mode for got pushed out a little bit.\" —Boris Cherny\n\n## Trade-offs\n\n**Pros:**\n\n- **Reduced token costs**: Shorter prompts = cheaper inference\n- **Faster execution**: Less processing overhead\n- **Simpler maintenance**: Less code/prompts to manage\n- **Future-proof**: Embraces model capabilities rather than fighting them\n- **Better performance**: Models often work better with less hand-holding\n\n**Cons:**\n\n- **Requires testing**: Must validate that quality doesn't degrade\n- **Version management**: May need different configs for different models\n- **Loss of explicit control**: Less visibility into model's internal reasoning\n- **Risk of regression**: Removing too much can hurt performance\n- **Documentation debt**: May lose understanding of why scaffolding was added\n\n**Strategic considerations:**\n\n- **When to remove**: After new model is proven stable in production\n- **How much to remove**: Start conservative, measure, iterate\n- **What to keep**: Domain-specific knowledge models can't know\n- **Migration path**: Support multiple model versions during transition\n\n## References\n\n* Boris Cherny: \"I just deleted like 2,000 tokens or something from the system prompt yesterday. Just because Sonnet 4.5 doesn't need it anymore. But Opus 4.1 did need it.\"\n* Boris Cherny: \"There's this frontier where you need to give the model a hard enough task to really push the limit... I think this is a general trend of stuff that used to be scaffolding with a more advanced model, it gets pushed into the model itself. The model kind of tends to subsume everything over time.\"\n* Cat Wu: \"We build most things that we think would improve Claude Code's capabilities, even if that means we'll have to get rid of it in three months. If anything, we hope that we will get rid of it in three months.\"\n* [AI & I Podcast: How to Use Claude Code Like the People Who Built It](https://every.to/podcast/transcript-how-to-use-claude-code-like-the-people-who-built-it)\n"
}
