{
  "title": "Three-Stage Perception Architecture",
  "status": "proposed",
  "authors": [
    "Nikola Balic (@nibzard)"
  ],
  "based_on": [
    "AI Architecture Community"
  ],
  "category": "Orchestration & Control",
  "source": "https://www.oreilly.com/library/view/software-architecture-patterns/9781491971437/",
  "tags": [
    "architecture",
    "perception",
    "processing",
    "action",
    "pipeline",
    "modular-design"
  ],
  "slug": "three-stage-perception-architecture",
  "id": "three-stage-perception-architecture",
  "summary": "TODO: Add a concise summary for \"Three-Stage Perception Architecture\" describing the pattern's purpose and key benefits.",
  "updated_at": "2026-01-05",
  "body": "\n## Problem\n\nComplex AI agents often struggle with unstructured inputs and need a systematic way to process information before taking action. Without a clear separation of concerns, agents can become monolithic and difficult to debug, extend, or optimize. Additionally, mixing perception, processing, and action logic makes it hard to swap out components or scale different parts of the system independently.\n\n## Solution\n\nImplement a three-stage pipeline architecture that cleanly separates an agent's workflow into distinct phases:\n\n1. **Perception Stage**: Handles all input gathering and normalization\n   - Receives raw inputs (text, images, audio, structured data)\n   - Performs initial processing (OCR, speech-to-text, format conversion)\n   - Normalizes data into a common internal representation\n\n2. **Processing Stage**: Performs reasoning and decision-making\n   - Analyzes normalized inputs using appropriate models\n   - Applies business logic and reasoning\n   - Makes decisions about what actions to take\n   - Can involve multiple sub-agents or reasoning steps\n\n3. **Action Stage**: Executes decisions in the environment\n   - Translates decisions into concrete actions\n   - Interfaces with external systems and APIs\n   - Handles error recovery and retries\n   - Reports results back to the system\n\n## Example\n\n```python\nclass ThreeStageAgent:\n    def __init__(self):\n        self.perception = PerceptionPipeline()\n        self.processor = ProcessingPipeline()\n        self.action = ActionPipeline()\n    \n    async def run(self, raw_input):\n        # Stage 1: Perception\n        perceived_data = await self.perception.process(raw_input)\n        \n        # Stage 2: Processing\n        decisions = await self.processor.analyze(perceived_data)\n        \n        # Stage 3: Action\n        results = await self.action.execute(decisions)\n        \n        return results\n\nclass PerceptionPipeline:\n    def __init__(self):\n        self.handlers = {\n            'text': TextHandler(),\n            'image': ImageHandler(),\n            'audio': AudioHandler(),\n            'structured': StructuredDataHandler()\n        }\n    \n    async def process(self, raw_input):\n        input_type = self.detect_input_type(raw_input)\n        handler = self.handlers[input_type]\n        \n        # Normalize to common format\n        normalized = await handler.normalize(raw_input)\n        \n        # Extract features\n        features = await handler.extract_features(normalized)\n        \n        return {\n            'type': input_type,\n            'normalized': normalized,\n            'features': features,\n            'metadata': handler.get_metadata(raw_input)\n        }\n\nclass ProcessingPipeline:\n    def __init__(self):\n        self.reasoning_engine = ReasoningEngine()\n        self.decision_maker = DecisionMaker()\n    \n    async def analyze(self, perceived_data):\n        # Apply reasoning based on input type and features\n        analysis = await self.reasoning_engine.reason(perceived_data)\n        \n        # Make decisions based on analysis\n        decisions = await self.decision_maker.decide(\n            analysis,\n            context=self.get_context()\n        )\n        \n        # Validate decisions\n        validated = await self.validate_decisions(decisions)\n        \n        return validated\n\nclass ActionPipeline:\n    def __init__(self):\n        self.executors = {\n            'api_call': APIExecutor(),\n            'database': DatabaseExecutor(),\n            'file_system': FileSystemExecutor(),\n            'notification': NotificationExecutor()\n        }\n    \n    async def execute(self, decisions):\n        results = []\n        \n        for decision in decisions:\n            executor = self.executors[decision.action_type]\n            \n            try:\n                result = await executor.execute(decision)\n                results.append({\n                    'decision': decision,\n                    'status': 'success',\n                    'result': result\n                })\n            except Exception as e:\n                # Handle errors gracefully\n                recovery_result = await self.attempt_recovery(decision, e)\n                results.append(recovery_result)\n        \n        return results\n```\n\n```mermaid\nflowchart LR\n    subgraph \"Perception Stage\"\n        A[Raw Input] --> B[Type Detection]\n        B --> C[Normalization]\n        C --> D[Feature Extraction]\n        D --> E[Structured Data]\n    end\n    \n    subgraph \"Processing Stage\"\n        E --> F[Reasoning Engine]\n        F --> G[Analysis]\n        G --> H[Decision Making]\n        H --> I[Validation]\n        I --> J[Action Plan]\n    end\n    \n    subgraph \"Action Stage\"\n        J --> K[Executor Selection]\n        K --> L[Action Execution]\n        L --> M[Error Handling]\n        M --> N[Results]\n    end\n    \n    N --> O[Feedback Loop]\n    O --> F\n    \n    style A fill:#ffebee,stroke:#c62828,stroke-width:2px\n    style J fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px\n    style N fill:#e3f2fd,stroke:#1565c0,stroke-width:2px\n```\n\n## Benefits\n\n- **Modularity**: Each stage can be developed, tested, and scaled independently\n- **Flexibility**: Easy to swap implementations for different stages\n- **Debugging**: Clear boundaries make it easier to identify where issues occur\n- **Reusability**: Stages can be shared across different agent types\n- **Scalability**: Different stages can be scaled based on their computational needs\n\n## Trade-offs\n\n**Pros:**\n- Clean separation of concerns\n- Easier to maintain and extend\n- Better error isolation\n- Enables specialized optimization per stage\n- Facilitates team collaboration (different teams per stage)\n\n**Cons:**\n- Additional complexity for simple tasks\n- Potential latency from stage transitions\n- Requires careful interface design between stages\n- May introduce overhead for data transformation between stages\n\n## References\n\n- [Software Architecture Patterns](https://www.oreilly.com/library/view/software-architecture-patterns/9781491971437/)\n- [Pipeline Pattern in ML Systems](https://ml-ops.org/content/mlops-principles)\n"
}