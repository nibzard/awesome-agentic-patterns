{
  "title": "Dual-Use Tool Design",
  "status": "best-practice",
  "authors": ["Nikola Balic (@nibzard)"],
  "based_on": ["Boris Cherny (Anthropic)", "Claude Code Team"],
  "category": "Tool Use & Environment",
  "source": "https://every.to/podcast/transcript-how-to-use-claude-code-like-the-people-who-built-it",
  "tags": ["tools", "ux", "slash-commands", "hooks", "human-ai-collaboration", "consistency"],
  "slug": "dual-use-tool-design",
  "id": "dual-use-tool-design",
  "summary": "TODO: Add a concise summary for \"Dual-Use Tool Design\" describing the pattern's purpose and key benefits.",
  "updated_at": "2026-01-05",
  "body": "\n## Problem\n\nBuilding separate tools for humans and AI agents creates:\n\n- **Maintenance overhead**: Two implementations of similar functionality\n- **Inconsistent behavior**: Human tools work differently than agent tools\n- **Learning curve**: Users must learn one interface, agents another\n- **Feature drift**: Human and agent capabilities diverge over time\n- **Testing burden**: Must validate both interfaces separately\n\n## Solution\n\nDesign all tools to be **dual-use**—equally accessible and useful to both humans and AI agents. When a human can invoke a tool manually, the agent should be able to call it programmatically, and vice versa.\n\n**Core principle**: \"Everything you can do, Claude can do. There's nothing in between.\"\n\n**Key characteristics of dual-use tools:**\n\n1. **Same interface**: Humans and agents use identical APIs/commands\n2. **Shared logic**: One implementation serves both use cases\n3. **Composable**: Tools can be chained by either humans or agents\n4. **Observable**: Both see the same outputs (transparency)\n5. **Documented once**: Single source of truth for behavior\n\n```pseudo\n# Dual-use slash command example\ndefine_slash_command(\"/commit\") {\n    steps: [\n        \"run linters\",\n        \"generate commit message from git diff\",\n        \"create commit with standard format\"\n    ],\n    callable_by: [\"human\", \"agent\"],\n    pre_allowed_tools: [\"git add\", \"git commit\"],\n    model: \"haiku\"  # same for both\n}\n\n# Human invocation\n$ /commit\n\n# Agent invocation\nagent.call_slash_command(\"/commit\")\n```\n\n## How to use it\n\n**Design principles:**\n\n1. **Start with human ergonomics**: If it makes sense to humans, it usually makes sense to agents\n2. **Make everything scriptable**: What humans can click, agents should be able to call\n3. **Shared state visibility**: Both see the same terminal output, file changes, etc.\n4. **Consistent permissions**: Same security rules apply to both\n\n**Claude Code implementation examples:**\n\n- **Slash commands**: `/commit`, `/pr`, `/feature-dev` work manually and in agent flows\n- **Hooks**: Humans can trigger hooks manually; agents trigger them automatically\n- **Bash mode**: `!command` visible to both human and agent in same terminal\n- **Permissions**: Pre-allowed tools work the same whether human or agent invokes them\n\n**Benefits observed:**\n\n> \"It's sort of elegant design for humans that translates really well to the models.\" —Boris Cherny\n\n## Trade-offs\n\n**Pros:**\n\n- **Reduced maintenance**: One tool implementation serves both audiences\n- **Consistency**: Identical behavior whether human or agent invokes\n- **Shared improvements**: Optimizations benefit both use cases\n- **Easier testing**: Single test suite validates both paths\n- **Better UX**: Humans can replicate agent workflows manually\n- **Transparency**: Agents use the same observable tools humans understand\n\n**Cons:**\n\n- **Design constraints**: Must satisfy both human ergonomics AND API cleanliness\n- **May compromise optimization**: Separate tools could be more specialized\n- **Complexity in edge cases**: Some behaviors might need conditional logic\n- **Documentation challenge**: Must explain dual usage clearly\n\n## References\n\n* Boris Cherny: \"Tools were built for engineers, but now it's equal parts engineers and models... everything is dual use.\"\n* Boris Cherny: \"I have a slash command for slash commit... I run it manually, but also Claude can run this for me. And this is pretty useful because we get to share this logic.\"\n* Cat Wu: \"Claude Code has access to everything that an engineer does at the terminal. Making them dual use actually makes the tools a lot easier to understand. Everything you can do, Claude can do. There's nothing in between.\"\n* [AI & I Podcast: How to Use Claude Code Like the People Who Built It](https://every.to/podcast/transcript-how-to-use-claude-code-like-the-people-who-built-it)\n"
}
