{
  "title": "Skill Library Evolution",
  "status": "established",
  "authors": ["Nikola Balic (@nibzard)"],
  "based_on": ["Anthropic Engineering Team", "Will Larson (Imprint)", "Amp (Nicolay)"],
  "category": "Learning & Adaptation",
  "source": "https://www.anthropic.com/engineering/code-execution-with-mcp",
  "tags": [
    "code-reuse",
    "skills",
    "learning",
    "capabilities",
    "evolution",
    "progressive-disclosure",
    "on-demand-loading",
    "mcp",
    "lazy-loading"
  ],
  "slug": "skill-library-evolution",
  "id": "skill-library-evolution",
  "summary": "Agents persist working code implementations as reusable skills that evolve into well-documented capabilities over time, building organizational knowledge and reducing redundant problem-solving across sessions.",
  "updated_at": "2026-01-13",
  "body": "\n## Problem\n\nAgents frequently solve similar problems across different sessions or workflows. Without a mechanism to preserve and reuse working code, agents must rediscover solutions each time, wasting tokens and time. Organizations want agents to build up capability over time rather than starting from scratch every session.\n\n## Solution\n\nAgents persist working code implementations as reusable functions in a `skills/` directory. Over time, these implementations evolve into well-documented, tested \"skills\" that become higher-level capabilities the agent can leverage.\n\n**Evolution path:**\n\n```mermaid\ngraph LR\n    A[Ad-hoc Code] --> B[Save Working Solution]\n    B --> C[Reusable Function]\n    C --> D[Documented Skill]\n    D --> E[Agent Capability]\n```\n\n**Basic pattern:**\n\n```python\n# Session 1: Agent writes code to solve a problem\ndef analyze_sentiment(text):\n    # Implementation discovered through experimentation\n    response = llm.complete(f\"Analyze sentiment: {text}\")\n    return parse_sentiment(response)\n\n# Agent saves working solution\nwith open(\"skills/analyze_sentiment.py\", \"w\") as f:\n    f.write(inspect.getsource(analyze_sentiment))\n```\n\n**Later session: Agent discovers and uses existing skill**\n\n```python\n# Agent explores skills directory\nskills = os.listdir(\"skills/\")\n# Finds: ['analyze_sentiment.py', 'extract_entities.py', ...]\n\n# Imports and uses existing skill\nfrom skills.analyze_sentiment import analyze_sentiment\n\nresult = analyze_sentiment(\"Customer feedback here...\")\n```\n\n**Evolved skill with documentation:**\n\n```python\n# skills/analyze_sentiment.py\n\"\"\"\nSKILL: Sentiment Analysis\n\nAnalyzes text sentiment using LLM completion and structured parsing.\n\nArgs:\n    text (str): Text to analyze\n    granularity (str): 'binary' or 'fine-grained' (default: 'binary')\n\nReturns:\n    dict: {'sentiment': str, 'confidence': float, 'aspects': list}\n\nExample:\n    >>> analyze_sentiment(\"Great product, fast shipping!\")\n    {'sentiment': 'positive', 'confidence': 0.92, 'aspects': ['product', 'shipping']}\n\nTested: 2024-01-15\nSuccess rate: 94% on validation set\n\"\"\"\ndef analyze_sentiment(text, granularity='binary'):\n    # Refined implementation\n    pass\n```\n\n**Progressive disclosure with on-demand loading (Imprint approach):**\n\nInstead of loading all skills into context, inject skill descriptions into system prompt and provide a `load_skills` tool for full content:\n\n```yaml\n# skills/pdf-processing/SKILL.md\n---\nname: pdf-processing\ndescription: Extract text and tables from PDF documents\nmetadata:\n  author: example-org\n  version: \"1.0\"\n---\n```\n\n```python\n# System prompt injection\nAVAILABLE_SKILLS = \"\"\"\nAvailable skills (use load_skills tool to read full content):\n- pdf-processing: Extract text and tables from PDF documents\n- slack-formatting: Format messages for Slack with proper mrkdwn\n- large-file-handling: Handle files exceeding context window\n\"\"\"\n\n# Tool for on-demand loading\ndef load_skills(skill_names):\n    \"\"\"Load full skill content into context.\"\"\"\n    for name in skill_names:\n        path = f\"skills/{name}/SKILL.md\"\n        # Read and inject full content\n```\n\n**Benefits of progressive disclosure:**\n- Reduces conflicting or unnecessary context\n- Minimizes formatting inconsistencies (e.g., Markdown vs Slack mrkdwn)\n- In-context learning examples stay focused on relevant tools\n\n**Lazy-loading MCP tools via skills (Amp approach):**\n\nMCP servers often expose many tools that consume significant context. Bind MCP servers to skills with selective tool loading:\n\n```json\n// skills/chrome-automation/mcp.json\n{\n  \"chrome-devtools\": {\n    \"command\": \"npx\",\n    \"args\": [\"-y\", \"chrome-devtools-mcp@latest\"],\n    \"includeTools\": [\n      \"navigate_page\",\n      \"take_screenshot\",\n      \"new_page\",\n      \"list_pages\"\n    ]\n  }\n}\n```\n\n**Token savings example:**\n- chrome-devtools MCP: 26 tools = 17k tokens\n- Lazy-loaded subset: 4 tools = 1.5k tokens (91% reduction)\n\nThe agent sees only the skill description initially. When invoked, only the specified tools are loaded into context.\n\n## How to use it\n\n**Implementation phases:**\n\n1. **Ad-hoc → Saved**\n\n   - Agent writes code to solve immediate problem\n   - If solution works, save to `skills/` directory\n   - Use descriptive names: `skills/pdf_to_markdown.py`\n\n2. **Saved → Reusable**\n\n   - Refactor for generalization (parameterize hard-coded values)\n   - Add basic error handling\n   - Create simple function signature\n\n3. **Reusable → Documented**\n\n   - Add docstrings with purpose, parameters, returns, examples\n   - Include any prerequisites or dependencies\n   - Note when last tested or validated\n\n4. **Documented → Capability**\n\n   - Agent can discover skills through directory listing\n   - Skills become part of agent's effective capability set\n   - Skills are composed into higher-level workflows\n\n**Skill organization:**\n\n```\nskills/\n├── README.md                 # Index of available skills\n├── data_processing/\n│   ├── csv_to_json.py\n│   └── filter_outliers.py\n├── api_integration/\n│   ├── github_pr_summary.py\n│   └── slack_notify.py\n├── text_analysis/\n│   ├── sentiment.py\n│   └── extract_entities.py\n└── tests/\n    └── test_sentiment.py     # Validation tests for skills\n```\n\n**Discovery pattern:**\n\n```python\n# Agent explores available skills\ndef discover_skills():\n    \"\"\"List available skills with descriptions.\"\"\"\n    skills = []\n    for root, dirs, files in os.walk(\"skills/\"):\n        for file in files:\n            if file.endswith(\".py\") and file != \"__init__.py\":\n                path = os.path.join(root, file)\n                # Extract docstring\n                with open(path) as f:\n                    content = f.read()\n                    docstring = extract_docstring(content)\n                skills.append({\n                    'path': path,\n                    'name': file[:-3],\n                    'description': docstring.split('\\n')[0] if docstring else ''\n                })\n    return skills\n```\n\n## Trade-offs\n\n**Pros:**\n\n- Builds agent capability over time\n- Reduces redundant problem-solving across sessions\n- Creates organizational knowledge base in code form\n- Skills can be tested, versioned, and improved\n- Enables composition of higher-level capabilities\n- Reduces token consumption (reuse vs. rewrite)\n\n**Cons:**\n\n- Requires discipline to save and organize skills\n- Skills can become stale or outdated\n- Need maintenance and testing infrastructure\n- Namespace conflicts if skills grow large\n- Agents must be prompted to check skills before writing new code\n- Quality varies (not all saved code is good code)\n\n**Maintenance requirements:**\n\n- Regular review of skill quality and relevance\n- Testing framework for skill validation\n- Deprecation policy for outdated skills\n- Documentation standards for new skills\n- Version control to track skill evolution\n\n**Success factors:**\n\n- Clear naming conventions\n- Good documentation from the start\n- Encourage skill reuse through prompting\n- Periodic skill library review and curation\n- Examples and test cases for each skill\n\n## References\n\n* Anthropic Engineering: Code Execution with MCP (2024)\n* [Building an internal agent: Adding support for Agent Skills](https://lethain.com/agents-skills/) - Will Larson (Imprint, 2025)\n* [Efficient MCP Tool Loading](https://ampcode.com/news/lazy-load-mcp-with-skills) - Amp (Nicolay, 2025)\n* Related: Compounding Engineering Pattern, CLI-First Skill Design\n"
}
