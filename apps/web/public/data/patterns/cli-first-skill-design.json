{
  "title": "CLI-First Skill Design",
  "status": "emerging",
  "authors": [
    "Lucas Carlson"
  ],
  "based_on": [
    "Anthropic (Claude Code)",
    "Unix Philosophy"
  ],
  "category": "Tool Use & Environment",
  "source": "https://github.com/anthropics/claude-code",
  "tags": [
    "cli",
    "skills",
    "shell",
    "dual-use",
    "composability",
    "unix-philosophy"
  ],
  "slug": "cli-first-skill-design",
  "id": "cli-first-skill-design",
  "summary": "Design all skills as CLI tools first for dual-use by humans and agents, enabling manual debugging, programmatic invocation, composition with Unix tools, and transparent shell-based execution without building separate interfaces.",
  "updated_at": "2026-01-05",
  "body": "\n## Problem\n\nWhen building agent skills (reusable capabilities), there's tension between:\n\n- **API-first design**: Skills as functions/classes—great for programmatic use, but hard to debug and test manually\n- **GUI-first design**: Skills as visual tools—easy for humans, but agents can't invoke them\n\nTeams end up building two interfaces or choosing one audience over the other.\n\n## Solution\n\nDesign all skills as **CLI tools first**. A well-designed CLI is naturally dual-use: humans can invoke it from the terminal, and agents can invoke it via shell commands.\n\n```mermaid\ngraph LR\n    A[Skill Logic] --> B[CLI Interface]\n    B --> C[Human: Terminal]\n    B --> D[Agent: Bash Tool]\n    B --> E[Scripts: Automation]\n    B --> F[Cron: Scheduled]\n```\n\n**Core principles:**\n\n1. **One script, one skill**: Each capability is a standalone executable\n2. **Subcommands for operations**: `skill.sh list`, `skill.sh get <id>`, `skill.sh create`\n3. **Structured output**: JSON for programmatic use, human-readable for TTY\n4. **Exit codes**: 0 for success, non-zero for errors (enables `&&` chaining)\n5. **Environment config**: Credentials via env vars, not hardcoded\n\n```bash\n# Example: Trello skill as CLI\ntrello.sh boards                    # List all boards\ntrello.sh cards <BOARD_ID>          # List cards on board\ntrello.sh create <LIST_ID> \"Title\"  # Create card\ntrello.sh move <CARD_ID> <LIST_ID>  # Move card\n\n# Human usage\n$ trello.sh boards\n{\"id\": \"abc123\", \"name\": \"Personal\", \"url\": \"...\"}\n{\"id\": \"def456\", \"name\": \"Work\", \"url\": \"...\"}\n\n# Agent usage (via Bash tool)\nBash: trello.sh cards abc123 | jq '.[0].name'\n```\n\n## How to use it\n\n**Skill structure:**\n\n```\n~/.claude/skills/\n├── trello/\n│   └── scripts/\n│       └── trello.sh          # Main CLI entry point\n├── asana/\n│   └── scripts/\n│       └── asana.sh\n├── honeybadger/\n│   └── scripts/\n│       └── honeybadger.sh\n└── priority-report/\n    └── scripts/\n        └── priority-report.sh  # Composes other skills\n```\n\n**CLI design checklist:**\n\n- [ ] Standalone executable with shebang (`#!/bin/bash`)\n- [ ] Help text via `--help` or no-args\n- [ ] Subcommands for CRUD operations\n- [ ] JSON output (pipe to `jq` for formatting)\n- [ ] Credentials from `~/.envrc` or environment\n- [ ] Meaningful exit codes\n- [ ] Stderr for errors, stdout for data\n\n**Composition example:**\n\n```bash\n# priority-report.sh composes multiple skill CLIs\n#!/bin/bash\necho \"## GitHub\"\ngh pr list --search \"review-requested:@me\"\n\necho \"## Trello\"\n~/.claude/skills/trello/scripts/trello.sh cards abc123\n\necho \"## Asana\"\n~/.claude/skills/asana/scripts/asana.sh tasks personal\n```\n\n## Trade-offs\n\n**Pros:**\n\n- **Dual-use by default**: Same interface for humans and agents\n- **Debuggable**: Run manually to test, inspect output\n- **Composable**: Pipe, chain, and combine with Unix tools\n- **Portable**: Works in any shell, no runtime dependencies\n- **Transparent**: Agent's tool calls are visible shell commands\n- **Testable**: Easy to write integration tests\n\n**Cons:**\n\n- **Shell limitations**: Complex data structures awkward in bash\n- **Error handling**: Less structured than exceptions\n- **Performance**: Process spawn overhead vs function calls\n- **State management**: No persistent state between invocations\n- **Windows compatibility**: Requires WSL or Git Bash\n\n**When to use something else:**\n\n- High-frequency calls (>100/sec): Use in-process functions\n- Complex object graphs: Use structured API\n- Real-time streaming: Use WebSocket/SSE\n\n## References\n\n* Unix Philosophy: \"Write programs that do one thing and do it well\"\n* Dual-Use Tool Design pattern\n* Claude Code skills directory structure\n* 12-Factor App: Config via environment\n"
}